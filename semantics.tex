\section{Semantics}
\label{sec:semantics}
\subsection{State}
\label{sec:state}
We represent the machine state mainly as a finite map of registers to register values and a map of masked physical memory addresses to 64-bit physical memory values. Together with default def\textsf{CPU} instantiation, we end up having our state with following pieces:
\begin{itemize}
\item A constant cpu initialized with default value: $\sigma.\mathcal{C}$
\item A register map: $\sigma.\mathcal{R}: \kw{greg} \rightarrow_{\textrm{fin}} \kw{regval} $
\item A memory map: $\sigma.\mathcal{M}: \Locft \rightharpoonup_{\textrm{fin}} (\Loctw \rightharpoonup_{\textrm{fin}} \Locsf )$
\end{itemize}
\subsection{Memory Addresses \& Naming Registers}
\label{sec:}
As one might have already anticipated from the syntax we introduce, we do not bind any value of an evaluated expression. All the indices and accessed values are treated as globally referenced. In align with this design choice, our expression is a stream of instructions, which is not evaluated to a value to be bound, but changes the machine state through the indices (e.g. $\kw{r}\in\kw{greg}$) -- to the global maps. 
\subsection{Instructions}
\label{sec:instrsemantics}
The syntax of instructions is given in \fref{fig:syntax}. Their
small-step operational semantics, a~reduction relation of the form
$\hsfork{\instr}{\store}{\instr'}{\store'}{\instrs}$,
is defined in \fref{fig:semantics}.
%
The last argument~$\instrs$ is a list of newly-spawned threads;
when it is empty, we omit it
and write just $\hs{\instr}{\store}{\instr'}{\store'}$.
\subsection{A Set of Selected Instructions Changing the Machine State}
\label{sec:selectedinstrsemantics}
In addition to the reduction rules in Figure \fref{fig:reductionsemantics} for the light-weight integration of our machine model to our simple language, and, finally, to our reasoning principles, we think that it is worth building the intuition on the way some of the instructions -- specifically the ones used in the examples contained in this paper -- change the machine state when reduced with \RULE{StepContext}. \RULE{StepMovRR} in \fref{fig:instrsemantics} shows how machine state change when we copy the source register's value ($\rvsrc$) referenced by the register name ($\rgsrc$) to the destination register ($\rgdst$). We follow the convention of showing only the pieces of the machine state changed after the instruction execution -- only the register value of the destiantion register ($ \readlval\rgdst\storeregprime\rvsrc$) has changed in the state ($\storeprime$) after the execution of the instruction $\textsf{mvrr}$. All the other rules in Figure \fref{fig:instrsemantics}, presents the change in the state when a value is loaded/stored to/from register/memory, and are differentiated with respect to the addressing mode ($amode$) which determines whether the accessed memory address is computed based on some offset (\RULE{StepMovRMOff}, \RULE{StepMovMROff}) or not (\RULE{StepMovRMBase}) and \RULE{StepMovMRBase}). The most common essential aspect of loading the source register's value ($\rvsrc$) to the memory, \RULE{StepMovRMBase} and \RULE{StepMovRMOff}, is the hierarchical translation of memory location, $\readlval\maddr{\storememstar\crval}\locsf$, which is hidden in the rules, expanded as the following:
\begin{itemize}
\item top-level-address translation: with the given root address (64-bit $\crval$) of the address space, performs the address translation, handling the first level (to get the PML4 entry) itself. The next level table address is computed with the fetched PML4 offset value which exhibits itself as 9-bit offset in $\kw{maddr}$.
\item translating from PML4 entry: performs the second level of address translation, to retrieve starting at the PML4 table entry, and interprets the PML4 entry that references a Page-Directory-Pointer Table (PDPT). We obtain the PDPT offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PDT)
\item translating from PD entry: performs the third level of address translation, to retrieve starting at the PDP table entry, and interprets a PDPTE that references a PD table. Likewise, we obtain the PD offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PT)
\item translate from PT entry: performs final level of address translation, starting from the PT entry, with a given 12 bit page offset, we can compute the physical address referencing $\locsf$
\end{itemize}
In fact $\readlval\maddr{\storememstar\crval}\locsf$ is unfoled into multiple physical memory lookups for the final page address retrieval -- i.e. address translation traversal as shown in Figure \ref{fig:pagetables}  \mytodo{1.address more about the challenging aspects of this traversal and the last level update}
\input{fig-semantics}
