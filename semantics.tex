\section{Semantics}
\label{sec:semantics}
\subsection{State}
\label{sec:state}
We represent the machine state mainly as a finite map of registers to register values and a map of masked physical memory addresses to 64-bit physical memory values. Together with default def\textsf{CPU} instantiation, we end up having our state with following pieces:
\begin{itemize}
\item A constant cpu initialized with default value: $\sigma.\mathcal{C}$
\item A register map: $\sigma.\mathcal{R}: \kw{greg} \rightarrow_{\textrm{fin}} \kw{regval} $
\item A memory map: $\sigma.\mathcal{M}: \Locft \rightharpoonup_{\textrm{fin}} (\Loctw \rightharpoonup_{\textrm{fin}} \Locsf )$
\end{itemize}
\subsection{Indexed Memory \& Register by References}
\label{sec:}
As one might have already anticipated from the syntax we introduce, we do not bind any value of an evaluated expression. All the indices and accessed values are treated as globally referenced. In align with this design choice, our expression is a stream of instructions, which is not evaluated to a value to be bound, but changes the machine state through the indices (e.g. $\kw{r}\in\kw{greg}$) -- to the global maps. 
\subsection{Instructions}
\label{sec:instrsemantics}
The syntax of instructions is given in \fref{fig:syntax}. Their
small-step operational semantics, a~reduction relation of the form
$\hsfork{\instr}{\store}{\instr'}{\store'}{\instrs}$,
is defined in \fref{fig:semantics}.
%
The last argument~$\instrs$ is a list of newly-spawned threads;
when it is empty, we omit it
and write just $\hs{\instr}{\store}{\instr'}{\store'}$.
\subsection{A Set of Selected Instructions Changing the Machine State}
\label{sec:selectedinstrsemantics}
In addition to the reduction rules in Figure \fref{fig:reductionsemantics} for the light-weight integration of our machine model to our simple language, and, finally, to our reasoning principles, we think that it is worth building the intuition on the way some of the instructions -- specifically the ones used in the examples contained in this paper -- change the machine state when reduced with \RULE{StepContext}. \RULE{StepMovRR} in \fref{fig:instrsemantics} shows how machine state change when we copy the source register's value ($\rvsrc$) referenced by the register name ($\rgsrc$) to the destination register ($\rgdst$). We follow the convention of showing only the pieces of the machine state changed after the instruction execution -- only the register value of the destiantion register ($ \readlval\rgdst\storeregprime\rvsrc$) has changed in the state ($\storeprime$) after the execution of the instruction $\textsf{mvrr}$. All the other rules in Figure \fref{fig:instrsemantics}, presents the change in the state when a value is loaded/stored to/from register/memory, and are differentiated with respect to the addressing mode ($amode$) which determines whether the accessed memory address is computed based on some offset (\RULE{StepMovRMOff}, \RULE{StepMovMROff}) or not (\RULE{StepMovRMBase}) and \RULE{StepMovMRBase}). The most common essential aspect of loading the source register's value ($\rvsrc$) to the memory, \RULE{StepMovRMBase} and \RULE{StepMovRMOff}, is the hierarchical translation of memory location, $\readlval{\plusaddr\maddr\offs}{\storememstar\crval}\locsf$, which is hidden in the rules, expanded as the following:
\begin{itemize}
\item
\item
\item
\item
\end{itemize}
where the first three levels of translation allows address-translation .
\input{fig-semantics}
