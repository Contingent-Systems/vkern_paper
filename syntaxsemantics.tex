\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]

\section{Machine State \& Syntax}
\label{sec:syntax}
To develop our core logical ideas, we instantiate \textsf{Iris} with a simple language for streams of instructions, 
and a logical machine model corresponding to execution of x86-64 assembly instructions with virtual memory enabled on the 
CPU.

\subsection{Registers and Memory}
Programs we demonstrate in this paper requires accessing two types of computer resource: registers and memory.
A register identifier, $\reg$, is chosen from a fixed finite set of register identifiers, $\regset$. 
We use these identifiers $\reg$ for register names such as \texttt{rax}, \texttt{r8}, or \texttt{cr3}.
% \begin{figure}[t]
% \newcommand{\commentary}[1]{ & \text{\small\it #1} \\}
% \[
%   \begin{array}{r@{\;}c@{\;}l}
%     \loc & \in & \Loc \\
%   \end{array}
%   \begin{array}{r@{\;}c@{\;}l}
%     \reg & \in & \regset \\
%   \end{array}
%   \begin{array}{r@{\;}c@{\;}l}
%     \regval & \in & \regvaltype \\
%     % \val & ::= & \vunit
%   \end{array}
% \quad
%   \begin{array}{r@{\;}c@{\;}l}
%     \instrs & ::= &
%     \begin{array}[t]{@{}l@{\hspace{10mm}}l@{}}
%     \begin{array}[t]{@{}ll@{}}
%       \iskip
%                    \commentary{no-op}
%       \iseq\instr\instrs
%                    \commentary{sequencing}
%       % \ising\instr
%                    % \commentary{executing}             
%     \end{array}
%     %&
%     %\begin{array}[t]{@{}ll@{}}
%      % \ialloc\lval\allocsize
%       %             \commentary{heap allocation}
%     %\end{array}
%     \end{array}
%     % \\
%     % \ectx & ::= &
%     %   \hole \mid
%     %   \iseq\ectx\instrs 
%     % \\
%   \end{array}
% \]
% \caption{Syntax}
% \Description{Syntax}
% \label{fig:syntax}
% \end{figure}
For clarity and ease of representation, we use machine words, $\loc \in \Loc$, with the subscripts showing the number of bits in a word,
for memory addresses, values, and offsets, rather than distinct location types that wrap machine words.
For example, $\kw{w}_{12}$ is a 12-bit word, which can be obtained for example truncating away 52 bits of a 64-bit word ($\kw{w}_{64}$).
\subsection{State}
\label{sec:state}
We represent the machine state mainly as a finite map of registers to register values and a map of word-aligned physical memory addresses 
to 64-bit physical memory values. 
Thus our states $\sigma$ include:
%Together with default \textsf{CPU} instantiation, we end up having our state with following pieces:
\begin{itemize}
%\item A constant cpu initialized with default value: $\sigma.\mathcal{C}$
\item A register map: $\sigma.\mathcal{R}: \kw{greg} \rightarrow_{\textrm{fin}} \kw{regval} $
\item A memory map: $\sigma.\mathcal{M}: \Locft \rightharpoonup_{\textrm{fin}} (\Loctw \rightharpoonup_{\textrm{fin}} \Locsf )$
\end{itemize}
Of particular note, \texttt{cr3}, the page table register, is included in the machine state.
% As one might have already anticipated from the syntax we introduce, we do not bind any value of an evaluated expression. All the indices and accessed values are treated as globally referenced. In align with this design choice, our expression is a stream of instructions, which is not evaluated to a value to be bound, but changes the machine state through the indices (e.g. $\kw{r}\in\kw{greg}$) -- to the global maps.
\subsection{Instructions}
\label{sec:instructions}

\begin{figure}[t]
\begin{lstlisting}[language=Coq,mathescape]
 Definition translate (rtv: word 64) ($\sigma$: state) (w: word 64): word 64 + MemFail :=
      l4e $\leftarrow$ translate_top_level $\sigma.\mathcal{M}$ rtv w; 
      l3e $\leftarrow$ translate_from_l4e $\sigma.\mathcal{M}$ l4e w; 
      l2e $\leftarrow$ translate_from_l3e $\sigma.\mathcal{M}$ l3e w;
      l1e $\leftarrow$ translate_from_l2e $\sigma.\mathcal{M}$ l2e w;
      addr $\leftarrow$ translate_from_l1e $\sigma.\mathcal{M}$ l1e w;
      return concat (shift_dropn addr 3 three_lt64) low3.
\end{lstlisting}
\vspace{-1em}
\caption{\coq implementation of address translation (slightly simplified).}
\label{fig:coq_addr_translation}
\end{figure}

Programs in our logic are instruction sequences \instrs, which are formed by either a basic instruction \iskip, or prefixing an existing instruction
sequence with an additional instruction (\iseq\instr\instrs).
We model (and later, give program logic rules for) instructions for basic register moves, and reading and writing memory.
The latter require page table walks.
Figure \ref{fig:coq_addr_translation} gives a slightly simplified version of our address translation code in monadic style:
starting from the root page table address \textsf{rtv}, the virtual address \textsf{w} is either resolved to a physical address or an error is returned.
The full set of possible errors is not relevant to this paper; our logic is tailored for kernel code which should not fault,
so our proof rules guarantee no memory failures occur --- that the page table walk for any dereferenced address will succeed.

% Page-table walk shown in Figure \ref{fig:pagetables} is realized with physical memory \texttt{load}s and \textsf{store}s for the entries in the 
% page-tables which are simply modelled as lookup and updates to an instance of a memory map with 64 bit entries. In the address translation,
% we see a physical memory $\mathsf{load}$ (i.e. physical memory map ($\sigma.\mathcal{M}$) for each level) for each level of page-table-walk 
% concluded with alignment of the returned address for each \textit{successful} page-table-walk traversal which is what our reasoning principles 
% only consider.

The main instructions we implement are variants of the x86-64 \lstinline|mov| instruction, which we format in Intel syntax (destination on the left, source on the right).
As expected \textsf{store} would be the update on the memory map entry
% After defining the translation in terms of physical load and store action, now we can define our memory \lstinline|mov| instructions
For memory operations, we treat
\[
\begin{array}{l}
  \hbox{(\TirNameStyle{WriteToMemFromReg})} \qquad
  \textsf{mov}~[r_m]~r_r \\
  \hbox{(\TirNameStyle{WriteToRegFromMem})} \qquad 
  \textsf{mov}~r_r~[r_m]
  \end{array}
  \]
which are realized by first translating the virtual-memory address of a memory location stored in $r_m$ to a physical memory location,
then updating those memory contents with the contents of register $r_r$ (\TirNameStyle{WriteToMemFromReg}) 
or loading the value at that physical memory location into the register $r_r$
(\TirNameStyle{WriteToRegFromMem}). 
% More \lstinline|mov| instructions operating with memory addresses can be found in the submission artifact for different addressing schemes and data sizes.
Additional variants (such as instructions which access memory at a constant offset from the virtual address stored in a register) are also treated.

For register operations, we support moves back and forth between any pair of registers, though the \coq formalization splits these according to whether
the source or destination registers are standard data registers (e.g., \lstinline|rax|) or control registers (e.g., \lstinline|cr3|).
% \[
% \begin{array}{l}
%   \hbox{(\TirNameStyle{WriteToRegFromReg})} \qquad 
%    \textsf{mov ireg64 ireg64} \\
%   \hbox{(\TirNameStyle{WriteToCtlRegFromReg})} \qquad 
%   \textsf{mov creg64 ireg64}\\
%     \hbox{(\TirNameStyle{WriteToRegFromCtlReg})} \qquad 
%   \textsf{mov ireg64 creg64}
%   \end{array}
% \]
% for different types of registers (e.g. control and general).
%
%\subsection{Machine State under Address Translation}
%\label{sec:selectedinstrsemantics}
%Althought we give the complete set of operational semantics rule in \sref{appendix:movops}, It is worth building the intuition on the the way some of these rules bahave in the context of address translation. In fact $\readlval\maddr{\storememstar\crval}\locsf$ is unfoled into multiple physical memory lookups for the final page address retrieval -- i.e. address translation traversal as shown in Figure \ref{fig:pagetables}:
%\begin{itemize}
%\item top-level-address translation: with the given root address (64-bit $\crval$) of the address space, performs the address translation, handling the first level (to get the PML4 entry) itself. The next level table address is computed with the fetched PML4 offset value which exhibits itself as 9-bit offset in $\kw{maddr}$. \mytodo{iso: put move}
%\item translating from PML4 entry: performs the second level of address translation, to retrieve starting at the PML4 table entry, and interprets the PML4 entry that references a Page-Directory-Pointer Table (PDPT). We obtain the PDPT offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PDT) \mytodo{iso: put move}
%\item translating from PD entry: performs the third level of address translation, to retrieve starting at the PDP table entry, and interprets a PDPTE that references a PD table. Likewise, we obtain the PD offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PT) \mytodo{iso:put move }
%\item translate from PT entry: performs final level of address translation, starting from the PT entry, with a given 12 bit page offset, we can compute the physical address referencing $\locsf$ \mytodo{ismo: put mov}
%\end{itemize}
