\section{Experiment}
\label{sec:experiment}
\mytodo{Mechanization is Ismail's Part -- Discussing and putting in here is Colin's}

To both validate and demonstrate the value of the modal approach to reasoning about virtual memory management, we study several distillations of real concerns of virtual memory managers.
Recall from Section \ref{sec:logic} that virtual points-to assertions work just like regular points-to assertions, by design.

\subsection{Identity Mappings}
\todo[inline]{need to describe this}

\subsection{Mapping a New Page}
One of the key tasks of a page fault handler in a general-purpose OS kernel is to map new pages into an address space by writing into an existing page table.
\todo[inline]{Ismail, see notes about intermediate assertions on the Notion page}
\begin{figure}
\begin{lstlisting}
;; Assume the faulting address f is in r12,
;; a callee-save register, and f with the 
;; lower 12 bits zeroed out (so, the virtual
;; page containing f) is in r13 (also callee-save)

;; Ensure there's a place to put the L1 mapping
mov %rdi, %r13
call ensure_L1_page
;; Returns the virtual address of the L1 entry in rax
mov %r14, %rax ;; Save that before another call
call alloc_phys_page_or_panic
;; Calculate new PTE by setting the low-order bits
;; of the physical page
add %rax, 3
;; update the page table entry, mapping the page
mov (%rcx), %rax
;; memset the newly-mapped page
mov %rdi, %r13
mov %rsi, 0
mov %rdx, 4096
call memset
;; The newly mapped page is full of 0s
\end{lstlisting}
\caption{Distilled code for mapping a new page}
\label{fig:mapping_code}
\todo[inline]{this is terribly ugly, should switch to minted}
\end{figure}

\todo[inline]{emphasize the write to the L1 page table is validated by the fact that the identity mapping exists}

\subsection{Unmapping a Page}
The reverse operation, unmapping a designated page that is currently mapped, is pleasingly the reverse: by flipping the entry back to an invalid entry, full ownership of the updated entry reverts back to the now-invalid cell of the L1 table.

\subsection{Change of Address Space}
A critical piece of \emph{trusted} code in verified OS kernels is the assembly code to change the current address space; current verified OS kernels currently lack effective ways to specify and reason about this low-level operation, for resaons outlined in Section \ref{sec:relwork}.

\todo[inline]{probably not much more than just the cr3 update, but could be extended to a full context switch since the instruction pointer isn't updated in a swtch}

\begin{figure}
\begin{lstlisting}
;; Assume the save-space is in rdi,
;; load-space in rsi
;; No need to save/restore caller-save regs
;; Save yielding context
mov 0[%rdi], %rbx
mov 8[%rdi], %rsp
mov 16[%rdi], %rbp
mov 24[%rdi], %r12
mov 32[%rdi], %r13
mov 40[%rdi], %r14
mov 48[%rdi], %r15
mov 56[%rdi], %cr3
;; Restore target context
mov %rbx, 0[%rsi] 
;; This switches to a new stack
;; This stack may not be mapped in the
;; current address space!
mov %rsp, 8[%rsi] 
mov %rbp, 16[%rsi]
mov %r12, 24[%rsi]
mov %r13, 32[%rsi]
mov %r14, 40[%rsi]
mov %r15, 48[%rsi]
;; Switch to the new address space
mov %cr3, 56[%rsi]
\end{lstlisting}
\caption{Basic task switch code that switches address spaces.}
\label{fig:swtch}
\end{figure}

Figure \ref{fig:swtch} gives simplified code for a basic task switch, the heart of an OS scheduler implementation. This is code that saves the context (registers and stack) of the running thread (here in a structure pointed to by \lstinline|rdi|'s value) and restores the context of an existing thread (from \lstinline|rsi|), including the corresponding change of address space for a target thread in another process.
This code assumes the System V AMD64 ABI calling convention, where the normal registers not mentioned are caller-save, and therefore saved on the stack of the thread that calls this code, as well as on the new stack of the thread that is restored, thus only the callee-save registers and \texttt{cr3} must be restored.\footnote{We are simplifying in a couple basic ways. First, we are ignoring non-integer registers (e.g., floating point, vector registers) entirely. Second, we are ignoring that the caller-save registers should still be initialized to 0 to avoid leaking information across processes. We focus on the core logical requirements.}
With the addition of a return instruction, this code would satisfy the C function signature\footnote{The name comes from the UNIX 6th Edition \lstinline|swtch| function, the source of the infamous ``You are not expected to understand this'' comment~\cite{lions1996lions}.}
\begin{lstlisting}[language=C]
void swtch(context_t* save, context_t* restore);
\end{lstlisting}
A call to this code begins executing one thread in one address space (whose information will be saved in \lstinline[language=C]|save|) and finishes execution executing a different thread in a different address space (whose information is initially in \lstinline[language=C]|restore|).

Because this code does not directly update the instruction pointer, it is worth explaining \emph{how} this switches threads: by switching stacks. This is meant to be called with a return address for the current thread stored on the current stack when called --- which must be reflected in the calling convention. In particular, the precondition of the return address on the initial stack requires the callee-save register values at the time of the call: those stored in the first half of the code.
Likewise, part of the invariant of the stack of the second thread, the one being restored, is that the return address on \emph{that} stack requires the saved callee-save registers stored in that context to be in registers as its precondition.

The wrinkle, and the importance of the modal treatment of assertions, is that the target thread's precondition is \emph{relative to its address space}, not the address space of the calling thread.
Thus the precondition of this code is that the then-current stack pointer has a return address expecting the then-current callee-save register values and suitablly updated (i.e., post-return) stack in the \emph{current} (initial) address space, while the stack pointer saved in the context to restore expects the same of the saved registers and stack \emph{in the other address space}. And the postcondition is analagous, but interpreted \emph{in a different address space}: the then-current (updated) stack has a return address expecting the new (restored) register values, and the saved context's invariant captures the precondition for restoring its execution \emph{in the previous address space}. At that point, it is safe to execute a return (or in a variant on this for user-mode and/or preemptive scheduling, a return-from-interrupt instruction).

In addition, immediately after the page table switch, the points-to information about the saved and restored contexts is \emph{also} guarded by a modality for the old address space, since there is no automatic guarantee that that memory is mapped in the new address space.  The ability to transfer that points-to information out of that modality is specific to a given kernel's design. Kernels that map kernel memory into all address spaces would need to ensure and specify enough specific details about memory mappings to allow a proof of an elimination rule for specific modally-constrained points-to assertions.
Following Spectre and Meltdown, this kernel design became less prevalent because speculative execution of accesses to kernel addresses could leak information even if the access did eventually cause a fault (the user/kernel mode permission check was done after fetching data from memory). Thus many modern kernels have reverted to the older kernel design where the kernel inhabits its own unique address space, and user processes have only enough extra material mapped in their address spaces to switch into the kernel (CPUs do not speculate past updates to \texttt{cr3}).


\todo[inline]{technically we weren't planning to prove reads of cr3...}
\todo[inline]{need to figure out the right pre/post condition to highlight the change in address space, beyond the vpoints-to of the two structures}