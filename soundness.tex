\section{Implementing Logical Machinery \& Soundness}
We instantiate our program logic, $[@]$, as an instantiation of Iris~\cite{iris}, and build our modal abstractions on top of it. 
\subsection{BI-Lifting for Address Space Modality}
\label{sec:bilifting}
\mytodo{we should put some stuff here}
\subsection{Soundness}
\label{sec:soundness}
Our logic, $[@]$, operates on the machine state, which means we do not need to augment the machine state, i.e. our logical state is exact logical representation of our machine state. Consequently, we do not require an invariant, $\mathcal{I}$, except from the fact that logical/physical associated maps representing the register/memory mappings have the same domain. This ensures the correct lifting of mappings in the machine state to the \emph{assertions} that the client of our logic uses, i.e. points-to assertions that are defined as the ownership of a fragment of the logical state.

Iris instantiation comes with the semantic definition for the weakest-precondition which we can refactor into Hoare triples, $\triple\pre\instr\post$, to specify actions using our reasoning principles, show that these triples are sound.

\subsection{The Soundness Statement}
\label{def:soundness:statement}
The operational semantics of our simple lang just executes the instruction of our x86-64 model. Therefore, our soundness argument is to show that any execution composed of actions in our machine model (some of which are shown in Figure \sref{sec:semantics}) does not end-up in a invalid state.guarantees that  (\sref{sec:valid}). A~program that attempts to ... stuck~(\sref{sec:instrsemantics}).
\begin{theorem}[Soundness of the Logic]
  \label{th:adequacy}
  Assuming that  Suppose $\triple{\textsf{valid\_init}}\instr\iTrue$ holds.
 The execution of the instruction~$\instrs$, beginning in an initial state, cannot result in a configuration where a thread is stuck.
\end{theorem}
which states that if the program~$\instr$, with the given \textsf{valid\_init} asserting a valid state initialization, satisfies a semantic Hoare
triple, then this program cannot crash: by a direct consequence of Iris's adequacy theorem~\cite[\S6.4]{iris}.

Moreover we need to show the validity of each rules in Figures \fref{fig:reasoning} and \fref{fig:laws}.
\begin{theorem}[Validity of the Reasoning Rules]
\label{th:validity}
  Each of the rules in Figures~\ref{fig:laws}
  and~\ref{fig:reasoning} is valid.
\end{theorem}
Due to the space limits in this paper, we do not mention each proof for these rules explicitly (which are already mechanized in Coq),
but the definitions and constructions used requires explanation.

Together, Theorems~\ref{th:adequacy} and~\ref{th:validity} guarantee that, if
the Hoare triple $\textsf{valid\_init }\instrs\;\iTrue$ can be obtained by applying
the reasoning rules of our logic, then the program~$\instrs$ is safe.

\subsection{Logical Constructions}
\label{sec:invariant}

Since our semantics operates right on top of the x86-64 machine state (with Iris terminology, physical store),
we do not need to augment the physical store for more abstract reasoning, consequently, we do not need to come up
with a complicated logical relations that ties the physical store to the
\logical store. 
\begin{definition}[Relation between Physical and \Logical Stores]
  \label{def:related}
  Since we pick the logical store exactly same with physical store,  
  two stores are \emph{related}, identical.
\end{definition}

We already have the physical and logical stores and a simple invariant between them. Now, we can rely on the following Assumption \ref{assumption} from Iris to utilize its logical constructions.
% The predicate gen_heap_interp.
\newcommand{\genheapinterp}[1]{\mathit{Heap}\;#1}
\newcommand{\genmemheapinterp}[1]{\mathit{MemHeap}\;#1}
% Our predicate pred (defined in ph.v), expanded.
\newcommand{\pred}[1]{\ownGhost\gammaPred{\authfull{(\mapone\predstore)}}}
% A notation for assigning fraction 1 to every element of \predstore.
\newcommand{\mapone}[1]{1.#1}
% The predicate mapsfrom_exact, expanded.
\newcommand{\mapsfromexact}[3]{
  \ownGhost\gammaPred{\authfrag{\singletonMap{#1}{(#2, #3)}}}
}
% A metavariable for a share.
\newcommand{\sh}{L'}
% The predicate mapsfrom, expanded.
\newcommand{\mapsfromdef}[3]{
  \exists\sh.\;
  \mapsfromexact{#1}{#2}{\sh} \star \pure{\sh \subseteq #3}
}

\begin{assumption}
\label{assumption}
Iris defines two pieces of ghost state
\begin{enumerate}
\item  defines a predicate $\genheapinterp\store.\mathcal{R}$
  that ties a store~$\store.\mathcal{R}$ to this ghost state,
  and defines the points-to assertion $\ppointsto\rg\rv\qfrac\rpts$
  in terms of this ghost state.
  This is visible in the paper~\cite[\S6.3.2]{iris}
  and in Iris's \texttt{gen\_heap} library~\cite{genheap}.
  %
  We re-use this machinery without change,
  so we do not repeat these definitions.
  We mention the predicate $\genheapinterp\!$
  in our own invariant (Definition~\ref{def:invariant}),
  where it is applied to the \logical store~$\store$.
\item unlike the points-to relation obtained by direct interpretion of $\genheapinterp\store.\mathcal{R}$ using Iris existing \textsf{gen\_heap\_interp},
  we define a new algebra (\textsf{gen\_mem\_UR}) for abstracting the nested maps due to different levels of masking in memory mappings. 
\end{enumerate}
\end{assumption}

\begin{definition}[Ghost State - Memory with Nested Mappings]
We define our custom-tailored algebra 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\( \textsf{gen\_memUR} \stackrel{def}{=}
  \authm(\;
  \Locft \;\fpfn\;
  (\Loctw \;\fpfn\;  (\textsc{Frac }, \mathord{+}) \times (\textsc{Agree } \Loc,\mathord{=}) )
  \)
  for our nested memory mapping abstracting two different machine word masking. Then, we register our \emph{authoritative camera} \cite[\S6.3.3]{iris} from this algebra
\[\textsf{inG } \Sigma \textsf{ gen\_memUR} \]
As a final step, we allocate an empty ghost cell $\gamma$ at the beggining of a program execution to store the element of the monoid $\textsf{inG } \Sigma \textsf{ gen\_memUR}$.
\end{definition}

\begin{definition}[Ghost State - Register Mappings]
We allocate $\theta$ ghost cell which stores an
element of the monoid 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\(
  \authm(\;
    \regset \;\fpfn\;
    (\textsc{Frac}, \mathord{+})
    \times
    (\regvaltype, \mathord{=})
  \;)
\)
% \emph{authoritative camera}
\cite[\S6.3.3]{iris}.
\end{definition}

\begin{definition}[Central Invariant]
\label{def:invariant}
The central invariant of our logic is, due to lack of need for augmenting the machine state, simply the state interpretation \cite[\S7.3]{iris} : 
\[
\centralinvariant\;\store \triangleq
\left\{
\def\arraystretch{1.2}
\begin{array}{l@{\quad\star\quad}l@{\quad}l}
  \genheapinterp\store & \star \\
   \genmemheapinterp\store
\end{array}
\right.
\]
\end{definition}

As noted earlier (Assumption~\ref{assumption}), the predicate
$\genheapinterp\!$ and the points-to assertion for register mappings is inherited from Iris. What
this means, as far as we are concerned, is that the points-to assertion is
defined in a standard manner: $\genheapinterp\!$ is applied to the physical store~$\store$, as is usually the case~\cite[\S6.3.2]{iris}.
Likewise, we define nested interpretation $\genmemheapinterp\!$ in terms of $\genheapinterp\!$ to obtain physical memory points-to relation.

In fact, long story short, all assertions in our logic, i.e. points-to assertions for registers and memory, really about the logical store, which is in our case identical to the physical store, so that we can reason about the physical store.

