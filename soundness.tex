\section{Implementing Logical Machinery \& Soundness}
We build our program logic, as an instantiation of Iris~\cite{iris}, and build our modal abstractions on top of it. 
\mytodo{we should put some stuff here}
\subsection{Soundness}
\label{sec:soundness}
Our logic, operates on the machine state, which means we do not need to augment the machine state. The invarian that we pick, \textit{central invariant} ($\mathcal{I}$\textsf{ASpace}), is just semantic interpretation of stores in the machine state, $\sigma$.R and $\sigma$.M. This semantic interpratation ensures the correct lifting of mappings in the machine state to the assertions that the client of our logic uses, i.e. points-to assertions that are defined as the ownership of a fragment of the logical state.

We prefer to skip explaining the steps used in instantiation of Iris because it is an almost standard procedure, has already been explained for many other logic \ref{}, and we are concerned with the page-count limitation. However, it is worh noting that once you instantiate Iris for your language, it comes with the semantic definition for the weakest-precondition which we can refactor into Hoare triples, $\triple\pre\instr\post$, to specify our  selected \textsf{AMD64} instructions shown in Figure \ref{fig:wpdamd}, and show that these triples are sound. 
\subsection{The Soundness Statement}
\label{def:soundness:statement}
The operational semantics of our simple lang just executes sequences of instructions in our x86-64 model. Therefore, our soundness argument is to show that any execution composed of instructions in our machine model (some of which are shown in Figure \sref{sec:semantics}) does not end-up in a invalid state.
\begin{figure*}
\small
\begin{mathpar}
\inferrule[Skip]{}{
  \triple\post\iskip\post
}

\inferrule[Seq]{
  \triple\pre{\instr_1}\midpoint \\
  \triple\midpoint{\instr_2}\post
}{
  \triple\pre{(\iseq{\instr_1}{\instr_2})}\post
}
\end{mathpar}
\caption{Structural Rules for Executing Instructions}
\Description{Reasoning Rules}
\label{fig:structural}
\end{figure*}

\begin{theorem}[Soundness of the Logic]
  \label{th:adequacy}
 Together with the assumptions on the initial state hold,
 the execution of the instruction~$\instrs$, beginning with this initial state, cannot result in a configuration where the execution is stuck.
\end{theorem}
which states that if the program~$\instr$, with the given \textsf{valid\_init} asserting a valid state initialization, satisfies a semantic Hoare
triple, then this program cannot crash: by a direct consequence of Iris's adequacy theorem~\cite[\S6.4]{iris}.

Moreover we need to show the validity of each rules in Figures \fref{fig:reasoning} and \fref{fig:laws}.
\begin{theorem}[Validity of the Reasoning Rules]
\label{th:validity}
  Each of the rules in Figures~\ref{fig:wpdamd}
  and~\ref{fig:structural} is valid.
\end{theorem}
Due to the space limits in this paper, we do not mention each proof for the rules in Figures \ref{fig:wpdamd} and \ref{fig:structural} within this section, but we provide mechanized proofs for all these in Coq as a part of our artifact submission.
However, we would like to give the definitions and constructions used in our proofs, and would like to give an outline of paper proof for \TirNameStyle{WriteToRegFromVirtMem} in Figure \ref{fig:wpdamd} within this section.

Together, Theorems~\ref{th:adequacy} and~\ref{th:validity} guarantee that, if
the Hoare triple $\textsf{valid\_init }\instrs\;\iTrue$ can be obtained by applying
the reasoning rules of our logic, then the program~$\instrs$ is safe.

\subsection{Logical Constructions}
\label{sec:invariant}
We already have the physical and logical stores and a simple invariant between them. Now, we can rely on the following Assumption \ref{assumption} from Iris to utilize its logical constructions.
% The predicate gen_heap_interp.
\newcommand{\genheapinterp}[1]{\mathit{Heap}\;#1}
\newcommand{\genmemheapinterp}[1]{\mathit{MemHeap}\;#1}
% Our predicate pred (defined in ph.v), expanded.
\newcommand{\pred}[1]{\ownGhost\gammaPred{\authfull{(\mapone\predstore)}}}
% A notation for assigning fraction 1 to every element of \predstore.
\newcommand{\mapone}[1]{1.#1}
% The predicate mapsfrom_exact, expanded.
\newcommand{\mapsfromexact}[3]{
  \ownGhost\gammaPred{\authfrag{\singletonMap{#1}{(#2, #3)}}}
}
% A metavariable for a share.
\newcommand{\sh}{L'}
% The predicate mapsfrom, expanded.
\newcommand{\mapsfromdef}[3]{
  \exists\sh.\;
  \mapsfromexact{#1}{#2}{\sh} \star \pure{\sh \subseteq #3}
}

\begin{assumption}
\label{assumption}
Iris defines two pieces of ghost state
\begin{enumerate}
\item  defines a predicate $\textsf{to\_gen\_heap }\store.\mathcal{R}$
  that ties a store~$\store.\mathcal{R}$ to this ghost state,
  and defines the points-to assertion $\ppointsto\rg\rv\qfrac\rpts$
  in terms of this ghost state.
  This is visible in the paper~\cite[\S6.3.2]{iris}
  and in Iris's \texttt{gen\_heap} library~\cite{genheap}.
  %
  We re-use this machinery without change,
  so we do not repeat these definitions.
  We mention the predicate $\genheapinterp\!$
  in our own invariant (Definition~\ref{def:invariant}),
  where it is applied to the \logical store~$\store$.
\item unlike the register points-to relation obtained by direct interpretion of $\textsf{to\_gen\_heap }\store.\mathcal{R}$ using Iris, the existing \textsf{gen\_heap\_heap},
  does not directly helps introducing the ghost we define a new algebra (\textsf{gen\_mem\_UR}) for abstracting the nested maps due to different levels of masking in memory mappings and an interpretation for this algebra. 
\end{enumerate}
\end{assumption}

\begin{definition}[Ghost State - Memory with Nested Mappings]
We define our custom-tailored algebra 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\( \textsf{gen\_memUR} \stackrel{def}{=}
  \authm(\;
  \Locft \;\fpfn\;
  (\Loctw \;\fpfn\;  (\textsc{Frac }, \mathord{+}) \times (\textsc{Agree } \Loc,\mathord{=}) )
  \)
  for our nested memory mapping abstracting two different machine word masking. Then, we register our \emph{authoritative camera} \cite[\S6.3.3]{iris} from this algebra
  \[\textsf{inG } \Sigma \textsf{ gen\_memUR} \]
  To interpret this nested ghost map we define \textsf{to\_gen\_mem}
  \[
  \begin{array}{l}
    \mathsf{to\_gen\_mem} : \textsf{ gmap L1 }(\textsf{gmap L2 V})\rightarrow \textsf{gen\_memUR L1 L2 V } := \textsf{ fmap} (\lambda \textsf{m . to\_gen\_heap m}). \\
     \mathsf{to\_gen\_heap } : \textsf{gmap L V} \rightarrow \textsf{gen\_heapUR L V} :=  (\lambda \textsf{v }\ldotp (1, \textsf{ to\_agree } (\textsf{v} : \textsf{leibnizO V}))).
  \end{array}
  \]
 throuh using \textsf{to\_gen\_heap} from previous Iris version. \todo[inline,color=red]{Ismail give exact version commit etc.}
As a final step, we allocate an empty ghost cell $\gamma$ at the beggining of a program execution to store the element of the monoid $\textsf{inG } \Sigma \textsf{ gen\_memUR}$.
\end{definition}

\begin{definition}[Ghost State - Register Mappings]
We allocate $\theta$ ghost cell which stores an
element of the monoid 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\(
  \authm(\;
    \regset \;\fpfn\;
    (\textsc{Frac}, \mathord{+})
    \times
    (\regvaltype, \mathord{=})
  \;)
\)
% \emph{authoritative camera}
\cite[\S6.3.3]{iris}.
\end{definition}

\begin{definition}[Central Invariant]
\label{def:invariant}
The central invariant of our logic is, due to lack of need for augmenting the machine state, simply the state interpretation: 
\[
\textsf{x64\_h}\;\store \triangleq
\left\{
\def\arraystretch{1.2}
\begin{array}{l@{\quad\star\quad}l@{\quad}l}
  \textsf{to\_gen\_heap} \;\store.\mathcal{R} &  \\
   \textsf{to\_gen\_mem} \; \store.\mathcal{M}
\end{array}
\right.
\]
\end{definition}

As a last definition, we give the head step relation required for the Iris instantiation for our simple language in Figure \ref{} to sequence instructions. This relation allows lifting the program expression to enables the application of changes imposed by the operational semantics on the program state $\sigma$ when applied for an insturction (\textsf{i}).
\[
\begin{array}{l}
\textsf{exec\_step} (\textsf{i}: \textsf{ instr}) (\sigma:\textsf{ state}):\textsf{ option state} \stackrel{def}{=} \\
\qquad \textsf{exec\_state} (\textsf{exec\_instr i } \sigma.(\textsf{cpu})  \\ \qquad (\textsf{regToregset } \sigma.(\mathcal{R}))  \\ \qquad ((\textsf{memToPhysMem }\sigma.(\mathcal{M})) (\textsf{exist \_}  \\ \qquad (\textsf{ regset\_get\_num }(\textsf{regToregset }\sigma.(\mathcal{R}))  (\textsf{ cr cr3}))))).
\end{array}
\]
\todo[inline,color=yellow]{Colin, in case needed,not proven, could you simply say that we assume these map equalities or a paper proof etc.}. Since the focus of this paper is not explaining our \textsf{AMD64} model, we prefer not to get into the details due to space limits. However, Coq formalization of our operational semantics is a part of our submission artifact.

Now, we have well-enough definition for giving an outline for the proof of \TirNameStyle{WriteToRegFromVirtMem}.
 \begin{lemma}[\textsc{\TirNameStyle{WriteToRegFromVirtMem}}]
   \label{lemma:unlink}
\begin{align*}
\inferrule{
  \{P \ast r_d \mapsto_{r}  \textsf{v} \ast r_a \mapsto_{r} \{q\} \textsf{ vaddr} \ast \textsf{vaddr} \mapsto_{\textsf{v,rtv}} \textsf{v} \}\;\overline{is}
}{
  \{P \ast r_d \mapsto_{r}  \textsf{rvd} \ast r_a \mapsto_{r} \{q\} \textsf{ vaddr} \ast \textsf{vaddr} \mapsto_{\textsf{v,rtv}} \textsf{v} \}
  \textsf{mov}~\textsf{r}_d,~\textsf{r}_a;\;\overline{is}
}
\end{align*}
 \end{lemma}
 
 \begin{proof}
   Assuming the inference rule realized with \textsf{wpd\_def}, we expand the precondition with $\textsf{cr3} \mapsto_{\textsf{r}} \rtv$.
   Then we do two proofs, one for head reducibility of atomic step \textsf{mov\_reg64\_mem64}, the second one for the executing the expression and obtaining the new state. Steps taken in the first one are subset of the second one, so we outline the second portion of the proof, but in case of an interest in details of the proof, Coq artifact can be consulted.

   \begin{itemize}
   \item Step 1: we apply the head step relation and obtain the current valid state $\sigma1$ interpretation : $\textsf{x64\_h}\;\store$
   \item Step 2: we unfold the virtual-pointsto ($\vaddr \mapsto_{\textsf{v,rtv}} \textsf{v}$) definition, and for an existential physical page address $\paddr$, we exchange our fragmental toke ($\sumwalkabs\vaddr\qfrac\paddr$) to obtain physical table-pointsto ($\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$ in Figure \ref{fig:strongvirtualpointsto}) relation
   \item Step 3: for each physical pointsto inside $\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$, we obtain
\[
       \ulcorner \sigma.\mathcal{M } !! (\textsf{ va}|^{52}(\textsf{ent}_i) = \textsf{Some } \sigma\textsf{d}_i \land
       \sigma\textsf{d }_i !! (\textsf{ va}|^{12}(\textsf{ent}_i)  = \textsf{Some entry}_{i+1} \urcorner
       \]
       where $\sigma.\textsf{d}_i$ in type \textsf{gmap (word 12) (word 64)} for our offset mappings. 
     \item Step 4: use these concrete lookups to traverse the page tables to obtain the value \textsf{v}
     \item Step 5: do the map update the $\sigma.\mathcal{R}$ for relevant register mapping ($r_d$) with the value \textsf{v} 
   \end{itemize}
   
   \end{proof}
