\section{Implementing Logical Machinery \& Soundness}
We instantiate our program logic, $[@]$, as an instantiation of Iris~\cite{iris}, and build our modal abstractions on top of it. 
\subsection{BI-Lifting for Address Space Modality}
\label{sec:bilifting}
\mytodo{we should put some stuff here}
\subsection{Soundness}
\label{sec:soundness}
Our logic, $[@]$, operates on the machine state, which means we do not need to augment the machine state, i.e. our logical state is exact logical representation of our machine state. Consequently, we do not require an invariant, $\mathcal{I}$, except from the fact that logical/physical associated maps representing the register/memory mappings have the same domain. This ensures the correct lifting of mappings in the machine state to the \emph{assertions} that the client of our logic uses, i.e. points-to assertions that are defined as the ownership of a fragment of the logical state.

Iris instantiation comes with the semantic definition for the weakest-precondition which we can refactor into Hoare triples, $\triple\pre\instr\post$, to specify actions using our reasoning principles, show that these triples are sound.

\subsection{The Soundness Statement}
\label{def:soundness:statement}
The operational semantics of our simple lang just executes the instruction of our x86-64 model. Therefore, our soundness argument is to show that any execution composed of actions in our machine model (some of which are shown in Figure \sref{sec:semantics}) does not end-up in a invalid state.guarantees that  (\sref{sec:valid}). A~program that attempts to ... stuck~(\sref{sec:instrsemantics}).
\begin{theorem}[Soundness of the Logic]
  \label{th:adequacy}
  Assuming that  Suppose $\triple{\textsf{valid\_init}}\instr\iTrue$ holds.
 The execution of the instruction~$\instrs$, beginning in an initial state, cannot result in a configuration where a thread is stuck.
\end{theorem}
which states that if the program~$\instr$, with the given \textsf{valid\_init} asserting a valid state initialization, satisfies a semantic Hoare
triple, then this program cannot crash: by a direct consequence of Iris's adequacy theorem~\cite[\S6.4]{iris}.

Moreover we need to show the validity of each rules in Figures \fref{fig:reasoning} and \fref{fig:laws}.
\begin{theorem}[Validity of the Reasoning Rules]
\label{th:validity}
  Each of the rules in Figures~\ref{fig:laws}
  and~\ref{fig:reasoning} is valid.
\end{theorem}
Due to the space limits in this paper, we do not mention each proof for these rules explicitly (which are already mechanized in Coq),
but the definitions and constructions used requires explanation.

Together, Theorems~\ref{th:adequacy} and~\ref{th:validity} guarantee that, if
the Hoare triple $\textsf{valid\_init }\instrs\;\iTrue$ can be obtained by applying
the reasoning rules of our logic, then the program~$\instrs$ is safe.

\subsection{Logical Constructions}
\label{sec:invariant}

Since our semantics operates right on top of the x86-64 machine state (with Iris terminology, physical store),
we do not need to augment the physical store for more abstract reasoning, consequently, we do not need to come up
with a complicated logical relations that ties the physical store to the
\logical store. 
\begin{definition}[Relation between Physical and \Logical Stores]
  \label{def:related}
  Since we pick the logical store exactly same with physical store,  
  two stores are \emph{related}, identical.
\end{definition}

We already have the physical and logical stores and a simple invariant between them. Now, we can rely on the following Assumption \ref{assumption} from Iris to utilize its logical constructions.
% The predicate gen_heap_interp.
\newcommand{\genheapinterp}[1]{\mathit{Heap}\;#1}
% Our predicate pred (defined in ph.v), expanded.
\newcommand{\pred}[1]{\ownGhost\gammaPred{\authfull{(\mapone\predstore)}}}
% A notation for assigning fraction 1 to every element of \predstore.
\newcommand{\mapone}[1]{1.#1}
% The predicate mapsfrom_exact, expanded.
\newcommand{\mapsfromexact}[3]{
  \ownGhost\gammaPred{\authfrag{\singletonMap{#1}{(#2, #3)}}}
}
% A metavariable for a share.
\newcommand{\sh}{L'}
% The predicate mapsfrom, expanded.
\newcommand{\mapsfromdef}[3]{
  \exists\sh.\;
  \mapsfromexact{#1}{#2}{\sh} \star \pure{\sh \subseteq #3}
}


\begin{assumption}
\label{assumption}
  Iris defines a certain piece of ghost state,
  defines a predicate $\genheapinterp\store$
  that ties a store~$\store$ to this ghost state,
  and defines the points-to assertion $\loc\fpointsto\qv\blk$
  in terms of this ghost state.
  This is visible in the paper~\cite[\S6.3.2]{iris}
  and in Iris's \texttt{gen\_heap} library~\cite{genheap}.
  %
  We re-use this machinery without change,
  so we do not repeat these definitions.
  We mention the predicate $\genheapinterp\!$
  in our own invariant (Definition~\ref{def:invariant}),
  where it is applied to the \logical store~$\store$.
\end{assumption}

\begin{definition}[Ghost State]
...
stores an element of the monoid
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\(
  \authm(\;
    \Loc \;\fpfn\;
    (\textsc{Frac}, \mathord{+})
    \times
    (\textsc{Multiset}(\Loc), \mathord\uplus)
  \;)
\)
% \emph{authoritative camera}
\cite[\S6.3.3]{iris}.
\end{definition}

\begin{definition}[Central Invariant]
\label{def:invariant}
The central invariant of our logic,
or \emph{state interpretation invariant} \cite[\S7.3]{iris},
is the following Iris assertion:
\[
\centralinvariant\;\store \triangleq
\left\{
\def\arraystretch{1.2}
\begin{array}{l@{\quad\star\quad}l@{\quad}l}
  \genheapinterp\store & \star \\
   \genheapinterp\store & \star
\end{array}
\right.
\]
\end{definition}

\begin{definition}[Assertions]
\label{def:assertions}
  The assertions of our ... are defined as follows:
  \begin{enumerate}
  \item
  % The definition of the points-to predicate is inherited from gen_heap.
  % It is implicitly parameterized by a ghost cell that holds the heap.
  The \emph{points-to assertion} ..
  is inherited from Iris (Assumption~\ref{assumption}).
  \item
  The \emph{map-of-map} for a single physical memory location,
  
  \item
  The \emph{location-virtualization-modal}
  \item
  The \emph{pointed-by assertion} .
  \end{enumerate}
\end{definition}

% What do these definitions mean?

Let us try and explain the most important aspects of these definitions.

In Iris, the state interpretation invariant~$\centralinvariant\;\store$ is an assertion that
holds of the \emph{physical store}~$\store$ in between every two steps of
computation. It is used by Iris in the definition of Hoare triples; we inherit
this definition from Iris.

Our definition of $\centralinvariant\;\store$ begins with an existential quantification over
a \emph{\logical store}~$\logicalstore$.
..........
%.......
