\section{Introduction}
\label{sec:intro}
In the UNIX-inspired designs typical of modern general-purpose kernels [93, 82, 89, 91], virtual memory management, the filesystem, and device subsystem are tightly
coupled, rely upon other core OS services (scheduling, interrupt dispatch, etc.), and are central
to higher-level functionality. For example, in Solaris Internals [91], McDougall and Mauro write:
“The virtual memory sub-system can be considered the core of a Solaris instance, and the implementation of Solaris virtual memory affects just about every other subsystem in the operating
system.” So by verifying a kernel with full-featured versions of these essential systems, following the
designs kernel developers have found valuable enough to preserve for decades, we can make essential
progress towards handling real kernels written using these designs. This goal is feasible because
the verification challenges faced by these systems are all instances of just three core concepts from
systems research and development, which apply more broadly than just in OS kernels: location
virtualization, caching, and using asymmetric protocols to coordinate shared resource usage. We
believe all three concepts are amenable to direct treatment using tools from modal logic.

Virtual memory managers (VMMs) use hardware memory management units (MMUs) on each
CPU to virtualize the addresses of memory regions. Software actually accesses memory in terms of
a logical (virtual) address which is translated to a physical address in memory by the MMU based
on kernel-controlled page tables stored in memory: a hardware-defined sparse tree-map structure,
which itself is accessed by the kernel through virtual addresses. This tree structure may alias the
same physical memory to multiple virtual addresses. Whole trees are shared between threads of a
process, and subtrees or data pages may be shared across processes (e.g., the kernel mapping ~\cite{91,
93}). Accessing an unmapped address produces a fault which the OS can use to kill the process
or take corrective action (like add a mapping) and resume the interrupted code. This allows the
kernel to restrict which memory is accessible to different processes, hide memory limits from user
programs, ensure process isolation, implement paging and copy-on-write behaviors for performance
and resource controls, and even implement live migration of virtual machines in hypervisors ~\cite{110,
31}. Modern hardware extends this idea with an IOMMU ~\cite{71, 11} the OS can use to similarly
mediate hardware device access to memory.

We plan to use families of modalities to describe
the truth of assertions in the virtual resources corresponding to virtual address spaces or logical
locations in a file system: a modality for each concept, with corresponding assertions about the
underlying physical resource.
For virtual memory, this might correspond to an assertion [r]P indicating that P holds in the
virtual address space rooted at r. This is essentially what hybrid logic [19, 49, 10, 48] calls a
satisfaction operator, which evaluates the truth of a predicate in a named alternative state (here,
address space). An example usage of this would be as part of the invariant for a sleeping thread
— ∃R : registerset. Context(ctxt, R) ∗ ∃P : Prop. [R.cr3]P ∗ {P ∗ CurrentRegs(R)}(R.rip) — that the
context structure at virtual address ctxt holds a certain register set, and that the precondition for
the stored instruction pointer rip is that register set and the virtual invariant P, which is true in
the saved context’s address space rooted at cr3. This would be required to ensure safety of context
switches between address spaces.
Virtual points-to assertions would need to be defined in terms of physical points-to assertions
and hardware-specific address translation assertions (as in Kolanski and Klein’s work), and paged
points-to assertions indicating the VMM had committed swap space to hold the appropriate value
on disk. The semantics of address translation assertions would be given as an extension to Kolanski
and Klein’s approach, which implicitly treats the memory state as a modal frame and the choice of
page table root as a world in Kripke-style semantics. They stopped short, however, of incorporating
the choice of world into the logic’s assertions, or treating overlapping address spaces, or transitions

between address spaces. Overlapping address spaces — both shared data, and shared page tables
which may see updates — can be coordinated with protocols to ensure those updates preserve
address space invariants. For filesystem addressing modalities, the interpretation is dictated by the
entirely by filesystem design rather than the hardware, but the concept is similar.
Both systems have an implicit notion of a “current” world. CPUs have a current address space
based on their page table register (CR3 for x86-64), and the logic must support reasoning about
changing the current address space. Copy-on-write filesystems have a corresponding fixed location
on disk pointing to the physical block of the latest filesystem snapshot. For example, for CPUs, we
would ideally like proof rules close to the following:
{P ∗ CR3 = r1 ∗ [r2](Q) ∗ rax = r2}mov cr3 rax{[r1](P) ∗ CR3 = r2 ∗ Q ∗ rax = r2}
This rule captures the notion that switching address spaces pulls information out of one modality
into the “current view” of memory, and leaves other assertions true relative to the previous address
space. But real code requires stronger reasoning. Code that performs task switches typically
establishes an invariant in one address space — such as that the save-context of the thread being
taken off the CPU is valid — that must still be known true in the new address space. The right
way to expose this knowledge transfer is not obvious
