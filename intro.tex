\section{Introduction}
\label{sec:intro}
Virtual memory management lies at the core of modern OS kernel implementation. It is deeply intertwined with most other parts of a typical general-purpose OS kernel design, including scheduling, hardware drivers, and even the filesystem buffer cache. In writing the authoritative reference on the internals of the Solaris kernel, McDougall and Mauro went so far as to claim that ``\emph{the virtual memory sub-system can be considered the core of a Solaris instance, and the implementation of Solaris virtual memory affects just about every other subsystem in the operating system}''~\cite{mcdougall2006solaris}.
This makes rich support for verification the virtual memory management subsystem of an OS kernel critical to the correctness of every other piece of an OS or any software running atop it.

At its core, the virtual memory functionality of modern CPUs is about \emph{location virtualization}: the memory locations
(addresses) seen by most code are not, in fact, the exact location in physical memory where data reside. Instead these 
are \emph{virtual} addresses, which are mapped to actual physical resources by the cooperation of the hardware and OS. 
This is what enables separation of process memory resources:
the OS manipulates hardware functionality to ensure that any attempt by a process to access memory not explicitly granted 
to it by the kernel will fail. But this is complicated by the fact that 
%the OS and hardware can also enable, shared (overlapping) access to physical memory regions; the fact that the kernel data structures themselves are accessed via virtual memory addresses; 
%and the fact that 
control over these mappings of virtual to physical addresses is itself mediated by \emph{in-memory data structures}, 
which the kernel still accesses via virtual address, leading to indirect cycles.
\looseness=-1

Further complicating matters, addresses themselves bear no information about which address space they originate 
from. 
%For user processes this is of little concern, as these have access to only their own address space. 
This is not a problem for usermode code, which only accesses its own address space.
But the kernel has
(or can grant itself) access to all address spaces. Mixing up addresses from different address spaces leads to severe bugs.
Proofs of kernel correctness must also track which \emph{assertions} hold in different address spaces:
some assertions should hold across all address spaces, while others hold in only one, and others may hold in 
multiple but still not all.

This kind of context-dependent assertion, where a fact may be true in one address space but not others, has a modal flavor. 
We propose tackling the verification of virtual memory subsystems (and kernels more broadly) by adapting ideas from hybrid
modal logic, which can label assertions true under \emph{other, named} circumstances (i.e., in another address space) with a 
modality indexed by a name for that space (in our case, the root of the page tables for an address space). This offers a 
\textit{convenient} and \textit{powerful} way to \emph{modularly}
isolate assertions specific to a particular address space,
explicitly state when an assertion is true across address spaces,
manipulate address spaces from within other address spaces, and
reason about change in address spaces.
This approach to reasoning about virtual memory is more flexible than prior program logic techniques~\cite{kolanski08vstte,kolanski09tphols}, 
which were only able to work with a single address space (the current address space on the CPU) because they were unable
to speak directly \emph{within the logic} about other address spaces, in addition to handling
the \emph{non-local} effects of page table updates whether within the current address space or across address spaces.
\looseness=-1

\paragraph{Contributions}
We develop these ideas in the form of a logic for working with virtual-address-space-relative assertions,
implemented as an embedded separation logic within Iris~\cite{jung2018iris}.
The result is a separation logic that lifts a number of major semantic restrictions present in the few
prior logics tackling virtual address translation.
The logic we develop covers core reasoning principles for reasoning about memory configurations and code
reliant upon or manipulating those memory configurations in the presence of in-memory page tables, the primary
memory protection mechanism across Intel/AMD's x86-64 processors, ARM's application class processors including
AArch64 CPUs, POWER, RISC-V, and other architectures.
We prove the soundness of our \textsf{vProp} logic with respect to a RISC-like fragment of \textsf{AMD64} instructions.
We verify simplified versions of several critical virtual-memory-related pieces of OS functionality, most importantly:
switching address spaces, converting physical addresses to virtual addresses for
software page table walks, and complete page table walk which backbones other essential functionalities of
virtual-memory which we discuss for mapping and unmapping pages. These examples demonstrate the suitability and flexibility of
a modal treatment of address spaces: each has a concise specification, each example either goes beyond the technical
capabilities of prior logics, or revisits an example from prior work with more details (treating parts of the kernel
invariant never addressed by prior work) and fewer assumptions (e.g., verifying virtual-to-physical conversion rather
than assuming it has already occurred).

% One aspect of virtual memory management we do not address in this paper is updates to the translation lookaside
% buffer (TLB) present in most CPUs. Like CertiKOS~\cite{?}, seL4~\cite{sel4tocs}, and most other OS verification
% efforts we currently trust insertion of TLB flush operations, whose locations are critical but also few and
% well-known (after unmapping memory, or changing address spaces). Tackling correctness of TLB invalidation
% rigorously is an additional challenging project unto itself~\cite{...} with similarities to but
% significant divergences from reasoning about weak memory models, which future work should combine
% with the present work.
