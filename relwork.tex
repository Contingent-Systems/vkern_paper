\section{Related Work}
\label{sec:relwork}

We will discuss two streams of related work: OS verification, and 
program logics with modalities.

\subsection{OS Kernel Verification}
There has been relatively little prior work on formal verification of virtual memory.
Instead, most OS verification work has focused on minimizing reasoning about virtual memory management.
The original \textsc{Verisoft} project~\cite{alkassar2008verisoft,alkassar2010pervasive,alkassar2008formal,dalinger2005verification,hillebrand2005address,alkassar2008formal,starostin2010formal} 
relied on custom hardware, which, among other things, always ran kernel code with virtual memory disabled, removing the circularity that is a key challenge of verifying
VMM code for real hardware: At that point page tables become a basic partial map data structure to represent user program address translations,
with an idiosyncratic format. It turns out that subsequent OS verification work also treats page tables this way, but
unsoundly given that other projects target hardware that \emph{does} run the kernel with address translation: they \emph{trust}
that the particular page table manipulations do not, for example, unmap kernel code (which can crash the machine even if done ``temporarily'').
% \footnote{A bug
% one author has personally encountered in a research kernel, though not one discussed here.}).
This is true for \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS,Sewell2013translation}, whose formal machine model omits address translation,
and \textsc{CertiKOS}~\cite{gu15,gu2016certikos,gu2018certikos,chen2016interrupts}, whose refinement proofs rely on
\textsc{CompCert}'s usermode-oriented memory model~\cite{leroy2008formal,leroy2009formally} which assumes
updates to one memory address are independent of updates to another ---
which is not true of page table updates.
 % which is not the case when a single page table write can make regions of memory inaccessible.
% \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS,Sewell2013translation} is a formally verified L4 microkernel~\cite{Liedtke1995,Liedtke1996} 
% (and the first verified OS kernel to run on real-world hardware), verified with a mix of refinement proofs and program logic reasoning down to the assembly level.
% Because \textsc{seL4} is a microkernel, most VMM functionality actually lives in usermode and is unverified, and moreover, 
% their hardware model omits address translation entirely and the MMU entirely~\cite{Klein2009seL4,seL4TOCS}. 
% As a result, the limited page table management present in the microkernel treats page tables as idiosyncratic tree-maps as in
% \textsc{Verisoft}, despite actually running with address translation.
% This is partly mitigated by manually identifying some trusted invariants (e.g., that the address range designated for the kernel is appropriately mapped)
% and setting up the proof to ensure those invariants are maintained (i.e., as an extra proof obligation not required by their hardware model).

% \textsc{CertiKOS}~\cite{gu15,gu2016certikos,gu2018certikos,chen2016interrupts} is a microkernel intended for use as a hypervisor.
% The overall approach in that body of work is many layers of refinement proofs, using a
%  proliferation of layers with small differences to keep most individual refinements tractable. In keeping with precursor work 
% on the project from the same group~\cite{vaynberg2012compositional}, the purpose of some layers is to abstract away from 
% virtual memory (as early as possible).
% The papers on \textsc{CertiKOS} do not explicitly detail the VMM beyond highlighting its existence and referencing
% that it performs mapping operations for user code.
% The work is clear, however, that it fully trusts low-level assembly fragments such as the instruction sequence which actually
% switches address spaces, rather than verifying them.
% We can also infer other limitations from the project's pervasive reliance on a modified \textsc{CompCert},
% which fixes an abstract memory model aimed at \emph{user-mode} C programs~\cite{leroy2008formal,leroy2009formally}. 
% \textsc{CompCert}'s model of memory cannot handle non-local updates, so we can conclude \textsc{CertiKOS}'s proofs cannot
% address impact of virtual memory mapping changes on the kernel itself.
Other work on OS verification either never progressed far enough to address VMM verification
(\textsc{Verisoft XT}~\cite{cohen2009vcc,cohen2010local,dahlweid2009vcc,cohen2013SOFSEM}), or uses memory-safe languages to enable safe cohabitation 
of a single address space by all processes (\textsc{Singularity}~\cite{Fahndrich2006language,Hunt2007singularity,Hunt2007sealing,Barnett2011specsharp}, \textsc{Verve}~\cite{Yang2010Verve},
and \textsc{Tock}~\cite{levy2017multiprogramming}). The latter approach ensures memory safety, but ignores other functional uses of virtual memory
hardware, like swapping~\cite{Denning1970VM} or exploiting copy-on-write techniques for dynamic migration of virtual machines~\cite{clark2005live}.
\looseness=-1

\citet{kolanski08vstte} are the only other researchers to study VMM verification against a realistic hardware
model, where page table updates are performed through virtual memory accesses (later adding C-level type modeling~\cite{kolanski09tphols}).
As noted in Section \ref{sec:overly-restrictive}, Kolanski and Klein's virtual points-to is similar to that in Figure \ref{fig:strongvirtualpointsto},
with the attendant problems discussed earlier and lifted by our model. Their approach had modal elements,
but the work never addressed the issues of managing multiple address spaces, switching address spaces, or
invariants referring to other address spaces, which our explicitly modal approach and case studies do address.
They verified a fraction of an ARM version of our Figure \ref{fig:mapping_code}, which assumed that they already had the virtual address
of the L1 entry (which they assumed existed), thereby skipping the physical-to-virtual conversion issues we treat in Section \ref{sec:p2v}.
Due to a lack of fractional permissions in their formalism, they incidentally pick up other limitations orthogonal to their
foundational focus: by requiring
a virtual points-to have \emph{full} ownership of the page table walk memory, they limit their system to having only as many
virtual points-to assertions as there are entries in the top-level table (4096) because they cannot share access to entries.
We inherit fractional permission support form \iris, and use it extensively (the overly-restrictive
Figure \ref{fig:strongvirtualpointsto} is already an improvement in this way).
 
% Some work has been done like ours, studying VMM verification separately from the rest of the kernel.
% One important outgrowth of the \textsc{seL4} project, not integrated into the main project's proof, was work by 
% Kolanski and Klein which studied verification of code against a hardware model that \emph{did} include address translation
%  --- the only work aside from ours to do so --- initially in terms of basic memory~\cite{kolanski08vstte} and subsequently 
% integrating source-level types into the interpretation~\cite{kolanski09tphols}. 
% They were the first work to model physical and virtual points-to assertions separately, defining virtual points-to assertions
% in terms of physical points-to assertions mimicking page table walks, and defining all of their assertions as predicates on a
% pair of (physical) machine memory and a page table root, an approach we improve on.

% They also define their virtual points-to assertions such that a virtual points-to $p\mapsto_\mathsf{v} a$ owns the full 
% lookup path to virtual address $p$. This means that given two virtual points-to assertions at the same time, such as 
% $p\mapsto_\mathsf{v}a \ast p'\mapsto_\mathsf{v}b$, the memory locations traversed to translate $p$ and $p'$ must be disjoint. 
% This means the logic has a peculiar limit on how many virtual points-to assertions can coexist in a proof. Since page tables 
% fan out, the bottleneck is the number of entries in the root table. For their 32-bit ARMv6 example, the top-level address is 
% still 4Kb (4096 bytes), and each entry (consumed entirely by a virtual points-to in their scheme) is 4 bytes, so they have a 
% maximum of 1024 virtual points-tos in their ARMv6 configuration. Any assertion which implies more than that number
% of virtual addresses are mapped implies false in their logic.
% (They do formulate their logic over an abstract model, but every architecture would incur a similar limitation.)
% % Na\"ively transferring their model to x86-64 4-level tables would yield a limit of 512 assertions (also a 4Kb root page, 
% % but 8-byte entries).
% Our definitions make use of fractional permissions throughout; Figure \ref{fig:strongvirtualpointsto}'s definition
% of \lstinline|L4_L1_PointsTo| ellides the specific fractions used, but it in fact asserts 1/512 ownership of
% the L1 entry, 1/($512^2$) of the L2 entry, and so on, so each entry may map the appropriate number of machine words.
% \looseness=-1

% As noted earlier, by collocating both the physical ownership of the page table walk
% as part of the virtual points-to itself these logics preempt support for changes to page tables which do not actually affect 
% address translation. We address this by moving from Figure \ref{fig:strongvirtualpointsto}'s definition (essentially Kolanski and Klein's
% with fractional sharing of intermediate table entries) to Figure \ref{fig:virtualpointstosharing}'s.
% \looseness=-1

% Kolanski and Klein do verify code to map in a new page by installing an L1 page table entry, akin to our Figure \ref{fig:mapping_code}.
% However, our logic treatment of mapping goes beyond theirs. 
% Kolanski and Klein must unfold machine semantics at one point in their proof of mapping correctness~\cite[p.~27]{kolanski08vstte}, while
% our logic permits us to conduct the proof entirely in separation logic.
% Their proofs also do not address
% converting physical addresses of page table entries to virtual addresses that can be used to access them.
% Their original low-level (pseudo-assembly) proof assumes the correct virtual address already exists~\cite{kolanski08vstte},
% and their subsequent C-level proof~\cite{kolanski09tphols} axiomatizes a function akin to our \lstinline|ensure_L1|.
% While full proof of \lstinline|ensure_L1|'s page table walk is ongoing work, we have verified that virtual-to-physical
% translation can be done in our logic with appropriate kernel invariants (Section \ref{sec:traversing}), while
% Kolanski and Klein's model may not be able to do so --- because the virtual points-to owns the physical resources associated with
% intermediate page table entries, it appears impossible to have a virtual points-to for a page table entry that is part of the
% page table walk for another virtual address.
% \looseness=-1

% The other major distinction is that Kolanski and Klein have no explicit accounting for other address spaces.
% Their logic does not deal with change of address space, and has no way to assert that certain facts hold
% in another address space.
% They verify only one address space manipulation: mapping a single unmapped page into the current address space (in both papers).
% We verify this, as well as a change-of-address-space, which requires us to introduce assertions for talking
% about other address spaces (we must know, for example, that the precondition of the code after the change must be true
% in the \emph{other} address space), and to deal with the fact that the standard frame rule
% for separation logic is unsound in the presence of address space changes and address-space-contingent assertions.
% Our approach in this paper uses modalities to distinguish virtual-address-based assertions that hold only in specific 
% address spaces, making it possible to manipulate other address spaces, and equally critically, to \emph{change} address 
% spaces while reasoning about correctness.

Unlike our work, Kolanski and Klein prove very useful embedding theorems stating that code that does not modify page table 
entries can be verified in a VM-ignorant program logic, and that proofs in that logic can be embedded into the VM-aware logic 
(essentially by interpreting ``normal'' points-to relations as virtual points-to facts). While we have not proven such a result,
an analagous result {should} hold of our work: consider that the doubles for the \texttt{mov} instructions
that access memory behave just as one would expect for a VM-ignorant logic~\cite{Chlipala2013Bedrock}.
With our general approach to virtual points-to assertions being inspired by Kolanski and Klein, \emph{both}
 our approach and theirs could in principle be extended to account for pageable points-to assertions by adding additional 
disjunctions to an extended points-to definition; embedding ``regular'' separation logic into such a variant
is the appropriate next step to extend reasoning to usermode programs running with a kernel that may demand-page the program's
memory.

\paragraph{Translation Lookaside Buffers}
As noted in Section \ref{sec:backgroundonmachinemodel}, we do not formally model or reason about TLBs.
TLB flushes are required only when addresses are removed from a virtual address space, or when changing
virtual address spaces. Because this occurs in few places in the kernel (in some, only 3 locations), full verified
kernels including \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS} and \textsc{CertiKOS}~\cite{gu15,gu2016certikos}
trust TLB management. Neither of the aforementioned systems has a hardware model including a TLB, so neither is able
to verify TLB management in any form --- they \emph{must} trust its operation.
\looseness=-1

The only place TLB code becomes particularly challenging is in multiprocessor kernels, where
not only must the running CPU flush its own TLB with special instructions, but it must send an inter-processor interrupt (IPI) to all
other cores to ensure they also flush the relevant ranges of their own TLBs.
Currently no formal hardware model exists with sufficient detail to reason about IPIs in full detail,
which would require extensions to model interactions with ACPI tables populated by firmware on desktop and server machines,
or flattened device trees for (semi-)embedded systems like single-board ARM and RISC-V machines, which tell the OS
important information about how to control other CPU cores;
plus the memory-mapped IO used to trigger those IPIs.
As a result, multicore extensions of \textsc{seL4}~\cite{von2013clustered} and \textsc{CertiKOS}~\cite{gu2016certikos} also trust this functionality.
\looseness=-1

% Fully grounded trust for this would require a formal model of how hardware populates ACPI tables and formal verification of ACPI
% parsing code on general-purpose desktop and server machines, or a formalized and verified
% parsing of flattened device trees (plus trust that a system was booted with a correct FDT) for (semi-)embedded systems like single-board
% ARM and RISC-V machines. Either route would also require detailed treatment of memory-mapped IO triggering
% interrupts on other CPUs. This is far beyond any formal model of computer hardware that exists today,
% and far out of scope for this paper.


% \citet{syeda2020formal,syeda2018program} are the only existing work to address formal verification of TLB management.
% They extend the work of \citet{kolanski08ssv,kolanski09tphols,kolanski09tphols}, and therefore inherit the limitations of that work discussed
% above. Their logic primarily tracks a set of mapped addresses and a set of
% cached addresses, and generally preserve a global invariant (in a global Hoare logic, not a separation logic)
% that the cached addresses are a subset of the mapped addresses. When this invariant is violated, the logic provides only
% a Hoare-style backwards assignment type rule with unconstrained assertion $P$, rather than providing structure in the logic
% for reasoning about how to restore the invariant. Most technical results in the paper focus on proving
% transparency lemmas, that code that \emph{does not} modify page tables (kernel code outside the VMM, user code)
% is unaffected by its existence. The one piece of kernel code verified is a sequence of 4 pseudo-instructions for changing address spaces
% which include \emph{only} the installation of a new page table root and flushing of the old address space from the TLB.

% Adapting Syeda and Klein's global reasoning principles to a separation logic is non-trivial, even though their approach
% does capture some intuition about TLB reasoning. And as noted above, in the absence of support for significant additional
% hardware functionality in the hardware model, this would be substantial work for only very limited gains in confidence compared
% to trusting single-core TLB managment.
% Thus we leave TLB management to our future work plans, where we believe it is best addressed in tandem with substantially
% richer hardware models than any currently existing.

The only other attempt to verify a change of address space was by \citet{syeda2018program,syeda2020formal}, whose focus was on TLB maintenance (which we
do not model). However, they verified only the 4 instructions to switch address spaces and update the TLB on an ARM processor, in isolation
(i.e., not the full context switch including changing stacks with address spaces).
The specification they proved for those instructions did not address program invariants that may be valid in one address space and not the other,
so is not flexible enough to extend directly to a full context switching primitive as in Figure \ref{fig:swtch},
in addition to inheriting other limitations from the work they extend, discussed above~\cite{kolanski08vstte,kolanski09tphols}.
\looseness=-1

The right eventual solution would be to combine our work
and theirs, which we leave to future work, as combining both the models and reasoning principles would be highly non-trivial.

\subsection{Program Logics with Modalities}
Modalities have long been a staple of program logics, at least as far back as Dijkstra's weakest precondition calculus~\cite{dijkstra1975guarded}
and Pratt's observation the Hoare triples
could be decomposed using the weakest-precondition modality of dynamic logic~\cite{pratt1976semantical},
in a form quite similar to what \iris uses today~\cite{jung2018iris}.
Variants of Nakano's later modality~\cite{nakano2000modality} have long been used to deal with step-indexing 
for impredicative and recursive features of logics and type systems~\cite{Appel2007,hobor2010theory,birkedal2011step,birkedal2013intensional,jung2018iris}.

As noted earlier, our other-space modality derives from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
\add{Readers mostly familiar with modalities in prominent program verification approaches~\cite{Appel2007,birkedal2013intensional,birkedal2011step,hobor2010theory,jung2018iris,nakano2000modality,pnueli1977temporal,pratt1976semantical}
may not recognize hybrid logics, but as we discuss in Section \ref{sec:relwork}, they (like temporal logics) trace their roots back to Arthur Prior in the 1950s.
}
Little prior work combines these ideas with program logics. \citet{brotherston2014parametric} show that traditional
nominals extends the expressive power of separation logic. \citet{gordon2019modal}
uses nominals to refer to states of other actors in an actor language.
In parallel with our work, \citet{wagner2024realistic} use a hybrid-logic-inspired modality
to abstract reference-counting specifics from specifications of a low-level application binary interface (ABI)
--- their $@_l(P)$ indicates that $l$ is the location of a reference count for resources satisfying $P$.
% As noted throughout the paper, the inspiration for our other-space modality comes from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
% where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
% We are aware of only two prior works combining hybrid logics with program logics specifically. 
% Brotherston and Villard~\cite{brotherston2014parametric} demonstrated that may properties true of various 
% separation logics are not definable in boolean \BI (\BBI), and showed that a hybrid extension \HyBBI allows
% most such properties to be defined (e.g., the fact that separating conjunction is cancellative is unprovable 
% in boolean \BI, but provable in \HyBBI). There, nominals named resources 
% (roughly, but not exactly, heap fragments). 
% Gordon~\cite{gordon2019modal} described a use of hybrid logic in the verification of actor programs, 
% where nominals named the local state of individual actors (with such assertions stabilized with a 
% rely/guarantee approach). 
Beyond these, there is limited work on the interaction of hybrid logic with general substructural logics, in restricted forms
that do not affect expressivity~\cite{despeyroux2014hybrid,chaudhuri2019hybrid}.\looseness=-1
% Primarily there is a line of work on hybrid linear logic (\HyLL)~\cite{despeyroux2014hybrid}, 
% originally used as a way to more conveniently express aspects of transition systems in linear logic. 
% However, \HyLL's proof rules offer no non-trivial interactions with multiplicative connectives 
% (every \HyLL proof can in fact be embedded into regular linear logic~\cite{chaudhuri2019hybrid}, 
% unlike Brotherston and Villard's \HyBBI, which demonstrably increases expressive power over its base \BBI.

% In both \HyLL and \HyBBI, nominals denote worlds with monoidal structure (as worlds in Kripke semantics
% for either LL or \BBI necessarily have monoidal structure). Our nominals, by contrast, 
% do not name worlds in the same sense with respect to Iris's CMRAs, 
% but in fact \emph{classes} of worlds, because the names are locations 
% (a means of \emph{selecting} resources) rather than resources.  
% A key difference is that the use of nominals in those logics corresponds specifically to hypothetical 
% reasoning about resources (until a nominal is connected to a current resource, in which case conclusions 
% can be drawn about the current resource), which means the modalities themselves do not ``own'' resources. 
% Instead, assertions under our other-space modality can and do
% have resource footprints.
% Pleasantly, we sidestep most of the metatheoretical complexity of those other substructural hybrid
% systems by building our logic within a substructural metatheory (\iris).

Some logics for weak memory models~\cite{dang2019rustbelt,dang2022compass} have been formalized
in \iris using pointwise lifting, parameterizing by thread-local views of events (an operationalization of the release-acquire + nonatomic
portion of the repaired C11 memory model~\cite{lahav2017repairing}). 
There modalities $\Delta_\pi(P)$ and $\nabla_\pi(P)$
represent that $P$ held before or will hold after certain memory fences by thread $\pi$.
The definitions of those specific modalities existentially quantify over other views, related to the ``current'' view (the one where
the current thread's assertions are evaluated), and evaluate $P$ with respect to those other views. This approach to parameterizing
assertion semantics by a point of evaluation, and evaluating modalized assertions at other points quanfied in the definition of a modality,
is the classic notion of modal assertions, 
whereas hybrid logics expose the choice of evaluation point in assertions,
allowing statements of more properties. 
In these weak memory examples this additional expressive power would not be useful,
because any relevant points of evaluation (thread views) are intimately tied to memory fences performed by the program, whereas
for virtual memory management the kernel must be able to choose or construct arbitrary other address spaces.
\looseness=-1

%   is what it means
% to have a modality at all.
% It is \emph{not}, however, an instance of hybrid logic, which is specifically demarcated by an assertion language where
% \emph{assertions}, not their semantics, choose and name the evaluation points for modal assertions.
% A hybrid extension of the aforementioned logics would include assertions which named specific views at which to evaluate
% $P$, in the syntax of the assertion (e.g., $\Delta_\pi^v(P):=\lambda\_\ldotp (P\;v)$) rather than the 
% $\Delta_\pi(P):= \lambda v\ldotp (\exists v_{rel}\ldotp \ownGhost{\pi}{\mathsf{RelV}(v_{rel})\;v} \ast (P\;v_{rel})))$ actually used.
% Note the hybrid version takes the place to evaluate $P$ as a parameter, and therefore allows the \emph{derived} (modal) logic to explicitly
% reason in terms of evaluation points, rather than hiding all points of evaluation in the internal definitions of modalities.
% This prior \iris-based work also uses modalities where the interpretations are fixed a priori by logic designers. In contrast, our
% address space modalities' interpretations can be changed by program behaviors via page table updates; the equivalent in the prior work would
% be if programs could directly manipulate the buffers used to model weak memory behaviors,
% which they cannot.\footnote{Note that the views modelled modally in this prior work are abstractions of a wide range of hardware, so such
% manipulation of corresponding hardware resources is in fact impossible,
% while the address space mappings in our work reflect known hardware components present in a variety of CPUs.}


