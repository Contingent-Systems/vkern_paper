\section{Related Work}
\label{sec:relwork}
We will discuss two streams of related work: OS verification, and 
program logics with modalities.

\paragraph{OS Kernel Verification}
There has been relatively little prior work on formal verification of virtual memory.
\replace{Instead, m}Most OS verification work \replace{has focused on minimizing}{minimizes} reasoning about virtual memory management.
The original \textsc{Verisoft} project~\cite{alkassar2008verisoft,alkassar2010pervasive,alkassar2008formal,dalinger2005verification,hillebrand2005address,alkassar2008formal,starostin2010formal} 
relied on custom hardware which always ran kernel code with virtual memory disabled, removing the circularity that is a key challenge of verifying
VMM code for real hardware: \replace{A}{a}t that point page tables become a basic partial map data structure to represent user program address translations,
with an idiosyncratic format. \replace{It turns out that s}{S}ubsequent OS verification work
\add{targets real hardware that uses virtual addressing in the kernel, but unsoundly
uses hardware models that do not.} 
\add{Thus} they \emph{trust}
that the particular page table manipulations do not, for example, unmap kernel code
 (which can crash the machine even if done ``temporarily'').%\footnote{\add{A ``fun'' bug one author encountered in an industrial prototype kernel.}}
% \footnote{A bug
% one author has personally encountered in a research kernel, though not one discussed here.}).
This is true for \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS,Sewell2013translation}, whose formal machine model omits address translation,
and \textsc{CertiKOS}~\cite{gu15,gu2016certikos,gu2018certikos,chen2016interrupts}, whose refinement proofs rely on
\textsc{CompCert}'s usermode-oriented memory model~\cite{leroy2008formal,leroy2009formally} which assumes
updates to one memory address are independent of updates to another ---
which is not true of page table updates.
Other work on OS verification either never progressed to VMM verification
(\textsc{Verisoft XT}~\cite{cohen2009vcc,cohen2010local,dahlweid2009vcc,cohen2013SOFSEM}),
or uses memory-safe languages
\replace{to enable safe cohabitation of a single address space by all processes}{for process isolation instead of address translation}
(\textsc{Singularity}~\cite{Fahndrich2006language,Hunt2007singularity,Hunt2007sealing,Barnett2011specsharp}, \textsc{Verve}~\cite{Yang2010Verve},
and \textsc{Tock}~\cite{levy2017multiprogramming})\replace{. The latter approach ensures}{, ensuring} memory safety, but ignor\replace{es}{ing} other functional uses of virtual memory
hardware, like swapping~\cite{Denning1970VM} or exploiting copy-on-write techniques for dynamic migration of virtual machines~\cite{clark2005live}.
\looseness=-1

\add{
 These limitations motivate work like ours on reasoning soundly about virtual memory management.
 As discussed earlier, 
}
\citet{kolanski08vstte} are the only other researchers to study VMM verification against a realistic hardware
model, where page table updates are performed through virtual memory accesses (later adding C-level type modeling~\cite{kolanski09tphols}).
As noted in Section \ref{sec:overly-restrictive}, Kolanski and Klein's virtual points-to is similar to that in Figure \ref{fig:strongvirtualpointsto},
with the attendant problems discussed earlier and lifted by our model. Their approach had modal elements,
but
\replace{the work never addressed the issues of managing multiple address spaces, switching address spaces, or
invariants referring to other address spaces, which our explicitly modal approach and case studies do address.
They verified a fraction of an ARM version of our Figure ??, which assumed that they already had the virtual address
of the L1 entry (which they assumed existed), thereby skipping the physical-to-virtual conversion issues we treat in Section ??.
}{
 did not tackle evaluations that would benefit from modality.
}
\add{
 Our work improves significantly on the technical capabilities of ther logic and
 evaluates on kernel code that is more complete and more challenging than theirs.
}
\looseness=-1

\add{
 Our modal approach makes it possible to specify address space changes cleanly, which their logic cannot do at all.
 Our use of virtual pte-points-to assertions enables nearly the same proof rules
 as standard memory accesses, and constructing virtual points-to information within the logic
 (c.f.\ the logical entailment between $\textsf{R}_\textsf{walk}$ and $\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$)
 whereas Kolanski and Klein must reason semantically about when the model state supports new virtual points-to assertions.
}

\add{
Kolanski and Klein verify the critical step of updating an already-located L1 entry to map a new page
(ARM assembly corresponding roughly to Lines \ref{line:l1entry_storeC} and \ref{line:l1entry_setpresent}
in our Figure \ref{fig:mapping_codeC}), but ignore the essential code
preceding that step --- which as our \lstinline|walkpgdir| and \lstinline|pte_get_next_table| verifications
demonstrate, side-steps a significant amount of complexity and critical reasoning tasks.
We have verified the entirety of the software page table walk up to mapping a new page, aside from a trusted physical memory allocator resembling
\lstinline|malloc|~\cite{Chlipala2013Bedrock,wickerson2010explicit}.
 As a consequence of tackling this larger verification challenge, our work is the first to formally specify large
 segments of the self-referential portion of an OS kernel's virtual memory management invariants (per Sections \ref{sec:p2vC} and \ref{sec:selfconditional}),
 and to reason about converting from physical addresses to virtual addresses efficiently.
\looseness=-1
}

Due to a lack of fractional permissions in their formalism, they incidentally pick up other limitations orthogonal to their
foundational focus: by requiring
a virtual points-to have \emph{full} ownership of the page table walk memory, they limit their system to having only as many
virtual points-to assertions as there are entries in the top-level table (\replace{4096}{512}) because they cannot share access to entries.
We inherit fractional permission support form \iris, and use it extensively (the overly-restrictive
Figure \ref{fig:strongvirtualpointsto} is already an improvement in this way).
\add{While we cannot claim credit for \textsc{Iris}'s extensive feature set, the fact that the model of our
assertions is based on a classic algebraic tool (pointwise lifting) makes our approach compatible with
other logical bases as well, such as \textsc{PulseCore}~\cite{ebner2025pulsecore} or \textsc{VST}~\cite{appel2014program}.
}
\looseness=-1
 
\replace{Unlike our work, Kolanski and Klein prove very useful embedding theorems stating that code that does not modify page table 
entries can be verified in a VM-ignorant program logic, and that proofs in that logic can be embedded into the VM-aware logic 
(essentially by interpreting ``normal'' points-to relations as virtual points-to facts).
}{
 Kolanski and Klein prove that updates to any memory locations that are not part of the page tables
 do not affect the interpretation of other memory addresses, just like on real hardware.
 This implies that programs that do not modify memory mappings could be reasoned about without
 concern for mappings.
}
\replace{While we have not proven {such a result},
an analagous result \replace{{should} hold}{holds} of our work:}{
 An analagous result should holds of our model (though we have not proven it).
}
\replace{ consider that the doubles for the}{Informally this is visible in the rules for}
\texttt{mov} instructions,
\replace{that access memory behave just as one would expect for}{which are nearly identical to rules in a} VM-ignorant logic~\cite{Chlipala2013Bedrock,ni2007contexts}.
\replace{With our general approach to virtual points-to assertions being inspired by Kolanski and Klein, \emph{both}
 our approach and theirs could in principle}{
  In principle both our approach and Kolanski and Klein's could
 } be extended to account for pageable points-to assertions by adding 
disjunctions to an extended points-to definition\add{,} \add{which would be}
 the appropriate next step to extend reasoning to usermode programs running with a kernel that may demand-page the program's
memory.
\looseness=-1

As noted in Section \ref{sec:backgroundonmachinemodel}, we do not formally model or reason about \add{translation lookaside buffers} \add{(}TLBs\add{)}.
\replace{TLB flushes are required only when addresses are removed from a virtual address space, or when changing
virtual address spaces.}{
 TLB flushes are necessary when a page is \emph{un}mapped, or when switching address spaces.
}
\replace{Because t}{T}his occurs in few places in \replace{the}{uniprocessor} kernel\add{s} (in some, only 3 locations), \add{so} full verified
kernels including \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS} and \textsc{CertiKOS}~\cite{gu15,gu2016certikos}
trust TLB management. Neither of the aforementioned systems has a hardware model including a TLB, so neither is able
to verify TLB management in any form --- they \emph{must} trust its operation.
\replace{
The only place TLB code becomes particularly challenging is in multiprocessor kernels, where
not only must the running CPU flush its own TLB with special instructions, but it must send an inter-processor interrupt (IPI) to all
other cores to ensure they also flush the relevant ranges of their own TLBs.
Currently no formal hardware model exists with sufficient detail to reason about IPIs in full detail,
which would require extensions to model interactions with ACPI tables populated by firmware on desktop and server machines,
or flattened device trees for (semi-)embedded systems like single-board ARM and RISC-V machines, which tell the OS
important information about how to control other CPU cores;
plus the memory-mapped IO used to trigger those IPIs.
As a result, multicore extensions of \textsc{seL4}~[?] and \textsc{CertiKOS}~[?] also trust this functionality.
}{
 This is true of multicore verified kernels as well~\cite{von2013clustered,gu2016certikos}, though there
 the situation becomes much more challenging: when unmapping pages, the running CPU must invalidate the relevant TLB entries locally,
 but also send an inter-procesor interrupt (IPI) to all other cores to ensure they also invalidate affected entries on their TLBs.
 No formal hardware model currently exists for IPIs on any architecture, or even for the memory-mapped IO
 used to trigger those IPIs.
}

The only \replace{other attempt to verify a change of address space was by}{work to tackle TLB code verification was}
\citet{syeda2018program,syeda2020formal},
\replace{whose focus was on TLB maintenance (which we do not model)}{who are also the only prior work on verifying address-space-aware context switching}.
However, they verified only the 4 instructions to switch address spaces and update the TLB on an ARM processor, in isolation
(i.e., not the full context switch including changing stacks with address spaces).
The specification they proved for those instructions did not address program invariants that may be valid in one address space and not the other,
so is not flexible enough to extend directly to a full context switching primitive as in Figure \ref{fig:swtchC}\replace{,}{.}
\add{Their logic adds an assertion tracking known-inconsistent addresses (i.e., recently-unmapped by a table update or change in page table root)
and their memory access rules require accessed memory to lie outside that set.
However their logic is proven sound against a generalized semantics where any page table change adds \emph{all}
addresses to the inconsistent set, which is too imprecise for finer-grained unmapping.
}
The right \replace{eventual}{general} solution would be to combine our work
and \add{an extension of} theirs, \add{a substantial project} which we leave to future work\replace{,}{.}
\add{
 No other prior work has considered address space changes during context switching. \textsc{XCAP}~\cite{ni2007contexts}
 and Bedrock~\cite{Chlipala2011Bedrock,Chlipala2013Bedrock,Chlipala2015webapp} deal
 only with usermode threading (in a single process). \textsc{CertiKOS} and \textsc{seL4} trust assembly primitives for
 context switches, and do  not model address translation for executing code.
 \looseness=-1
}

\paragraph{Program Logics with Modalities}
Modalities have long been a staple of program logics, at least \replace{as far back as}{since} Dijkstra's weakest precondition calculus~\cite{dijkstra1975guarded}
and Pratt's observation the Hoare triples
could be decomposed using the weakest-precondition modality of dynamic logic~\cite{pratt1976semantical},
in a form quite similar to what \iris uses today~\cite{jung2018iris}.
Variants of Nakano's later modality~\cite{nakano2000modality} have long been used to deal with step-indexing 
for impredicative and recursive features of logics and type systems~\cite{Appel2007,hobor2010theory,birkedal2011step,birkedal2013intensional,jung2018iris}.
\looseness=-1

As noted earlier, our other-space modality derives from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
\add{Readers mostly familiar with modalities in prominent program verification approaches~\cite{Appel2007,birkedal2013intensional,birkedal2011step,hobor2010theory,jung2018iris,nakano2000modality,pnueli1977temporal,pratt1976semantical}
may not recognize hybrid logics, but as we discuss in Section \ref{sec:relwork}, they (like temporal logics) trace their roots back to Arthur Prior in the 1950s.
}
Little prior work combines these ideas with program logics. \citet{brotherston2014parametric} show that traditional
nominals extends the expressive power of separation logic. \citet{gordon2019modal}
uses nominals to refer to states of other actors in an actor language.
In parallel with our work, \citet{wagner2024realistic} use a hybrid-logic-inspired modality
to abstract reference-counting specifics from specifications of a low-level application binary interface (ABI)
--- their $@_l(P)$ indicates that $l$ is the location of a reference count for resources satisfying $P$.
% As noted throughout the paper, the inspiration for our other-space modality comes from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
% where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
% We are aware of only two prior works combining hybrid logics with program logics specifically. 
% Brotherston and Villard~\cite{brotherston2014parametric} demonstrated that may properties true of various 
% separation logics are not definable in boolean \BI (\BBI), and showed that a hybrid extension \HyBBI allows
% most such properties to be defined (e.g., the fact that separating conjunction is cancellative is unprovable 
% in boolean \BI, but provable in \HyBBI). There, nominals named resources 
% (roughly, but not exactly, heap fragments). 
% Gordon~\cite{gordon2019modal} described a use of hybrid logic in the verification of actor programs, 
% where nominals named the local state of individual actors (with such assertions stabilized with a 
% rely/guarantee approach). 
Beyond these, there is limited work on the interaction of hybrid logic with general substructural logics, in restricted forms
that do not affect expressivity~\cite{despeyroux2014hybrid,chaudhuri2019hybrid}.\looseness=-1
% Primarily there is a line of work on hybrid linear logic (\HyLL)~\cite{despeyroux2014hybrid}, 
% originally used as a way to more conveniently express aspects of transition systems in linear logic. 
% However, \HyLL's proof rules offer no non-trivial interactions with multiplicative connectives 
% (every \HyLL proof can in fact be embedded into regular linear logic~\cite{chaudhuri2019hybrid}, 
% unlike Brotherston and Villard's \HyBBI, which demonstrably increases expressive power over its base \BBI.

% In both \HyLL and \HyBBI, nominals denote worlds with monoidal structure (as worlds in Kripke semantics
% for either LL or \BBI necessarily have monoidal structure). Our nominals, by contrast, 
% do not name worlds in the same sense with respect to Iris's CMRAs, 
% but in fact \emph{classes} of worlds, because the names are locations 
% (a means of \emph{selecting} resources) rather than resources.  
% A key difference is that the use of nominals in those logics corresponds specifically to hypothetical 
% reasoning about resources (until a nominal is connected to a current resource, in which case conclusions 
% can be drawn about the current resource), which means the modalities themselves do not ``own'' resources. 
% Instead, assertions under our other-space modality can and do
% have resource footprints.
% Pleasantly, we sidestep most of the metatheoretical complexity of those other substructural hybrid
% systems by building our logic within a substructural metatheory (\iris).

Some logics for weak memory models~\cite{dang2019rustbelt,dang2022compass} have been formalized
in \iris using pointwise lifting, parameterizing by thread-local views of events (an operationalization of the release-acquire + nonatomic
portion of the repaired C11 memory model~\cite{lahav2017repairing}). 
There modalities $\Delta_\pi(P)$ and $\nabla_\pi(P)$
represent that $P$ held before or will hold after certain memory fences by thread $\pi$.
The definitions of those specific modalities existentially quantify over other views, related to the ``current'' view (the one where
the current thread's assertions are evaluated), and evaluate $P$ with respect to those other views. This approach to parameterizing
assertion semantics by a point of evaluation, and evaluating modalized assertions at other points quanfied in the definition of a modality,
is the classic notion of modal assertions, 
whereas hybrid logics expose the choice of evaluation point in assertions,
allowing statements of more properties. 
In these weak memory examples this additional expressive power would not be useful,
because any relevant points of evaluation (thread views) are intimately tied to memory fences performed by the program, whereas
for virtual memory management the kernel must be able to choose or construct arbitrary other address spaces.
\looseness=-1

%   is what it means
% to have a modality at all.
% It is \emph{not}, however, an instance of hybrid logic, which is specifically demarcated by an assertion language where
% \emph{assertions}, not their semantics, choose and name the evaluation points for modal assertions.
% A hybrid extension of the aforementioned logics would include assertions which named specific views at which to evaluate
% $P$, in the syntax of the assertion (e.g., $\Delta_\pi^v(P):=\lambda\_\ldotp (P\;v)$) rather than the 
% $\Delta_\pi(P):= \lambda v\ldotp (\exists v_{rel}\ldotp \ownGhost{\pi}{\mathsf{RelV}(v_{rel})\;v} \ast (P\;v_{rel})))$ actually used.
% Note the hybrid version takes the place to evaluate $P$ as a parameter, and therefore allows the \emph{derived} (modal) logic to explicitly
% reason in terms of evaluation points, rather than hiding all points of evaluation in the internal definitions of modalities.
% This prior \iris-based work also uses modalities where the interpretations are fixed a priori by logic designers. In contrast, our
% address space modalities' interpretations can be changed by program behaviors via page table updates; the equivalent in the prior work would
% be if programs could directly manipulate the buffers used to model weak memory behaviors,
% which they cannot.\footnote{Note that the views modelled modally in this prior work are abstractions of a wide range of hardware, so such
% manipulation of corresponding hardware resources is in fact impossible,
% while the address space mappings in our work reflect known hardware components present in a variety of CPUs.}


