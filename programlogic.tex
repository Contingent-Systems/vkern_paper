\section{Program Logic for Location Virtualization}
\label{sec:logic}
In this section, we describe our high-level reasoning principles for location virtualization whose detailed justification is shown in \sref{sec:soundness}. 
\subsection{Points-To Assertions}
\label{sec:pointsto}

We present three main points-to relations as part of utilization of separation logic \ref{} as an ambient logic:
\begin{enumerate}
\item Physical address points-to, $\pfpointsto\locsf\locsf\qfrac\ppts$
\item Register points-to, $\pfpointsto\rg\rv\qfrac\rpts$
\item Virtual memory address points-to, $\pfpointsto\vaddr\locsf\qfrac\vpts$
\end{enumerate}
\paragraph{Register points-to} The assertion $\pfpointsto\rg\rv\rpts\qfrac$ ensures the ownership of the register $\rg$ naming the register value $\rv$. The fraction $\qfrac$ with value 1 asserts the unique ownership of the register mapping, and grants update permission on it, otherwise, any value $0 < \qfrac <1$ represents partial ownership granting readonly permission on the mapping.
\paragraph{Physical-Memory points-to} The our physical memory points-to relation ($\pfpointsto\locsf\locsf\qfrac\ppts$) exhibits nested-mappings due to masking applied on the indexing address ($\locsf$). The unfolded definition of the physical mapsto 
\begin{figure}[!ht]
\[
\begin{array}{cl}
\pfpointsto\locsf\locsf\qfrac\ppts \stackrel{def}{=} & \nfpointsto{\mask\locsf\tw}{\mask\locsf\ft}\locsf\qfrac\naddr
\end{array}
\]
\caption{Physical Points-to with Nested Masking}
  \label{fig:physicalpointsto}
\end{figure}
where we simply abstract the generation of hierarchical mapping of a physical address ($\locsf$) through the different masks of the address ($\locsf|^{12}$ and $\locsf|^{52}$) as nested map resources.
\paragraph{Virtual-Memory points-to} As we see in Figure \fref{fig:}, virtual address mapping is obtained via traversal of page table, i.e. indirection provided by physical memory lookups. As expected, we define the virtual-points to relation, ($\pfpointsto\vaddr\locsf\qfrac\vpts$), in terms of multiple physical memory mappings representing the indirection shown in Figure \fref{fig:}
\begin{figure*}
\[
\begin{array}{cl}
  \ppointsto\locsf\locsf'\vpts \stackrel{def}{=} \lambda \tlf\Loc.
  & \exists_{\tlfoff\Locn \;, \tltoff\Locn \;, \tltwoff\Locn \;, \tlooff\Locn \;, \tpgoff\Loctw \;, \tlt\Loc \;, \tltw\Loc \;, \tlo\Loc \tpg\Loc}\\
  & \textsf{aligned } \locsf \\
  & \locsf = \locsx ++ \lfoff ++ \ltoff ++ \ltwoff ++ \looff ++ \pgoff \\
  &  \pfpointsto{\lvlsum\crt\lfoff}{\lvlbor\lt}\qfrac\ppts \\
  &  \pfpointsto{\lvlsum\lt\ltoff}{\lvlbor\ltw}\qfrac\ppts \\
  & \pfpointsto{\lvlsum\ltw\ltwoff}{\lvlbor\lo}\qfrac\ppts \\
  & \pfpointsto{\lvlsum\lo\looff}{\lvlbor\pg}\qfrac\ppts \\
  & \ppointsto{\pageptstosum\pg\pgoff}\locsf'\ppts \\

\end{array}
\]
\caption{Virtual Points-to Relation}
  \label{fig:virtualpointsto}
\end{figure*}

\subsection{Modal Abstraction for Virtualizing Memory Locations}
\label{sec:modallocationvirtualization}
\input{fig-laws}

\subsection{Reasoning Rules for Selected Instructions}
\label{sec:reasoning}
\input{fig-reasoning}
As is usual in \SL, the reasoning rules of the program logic allow deriving
Hoare triples of the form $\triple\pre\instr\post$, where the
precondition~$\pre$ and the postcondition~$\post$ are assertions,
and where $i$ is an instruction.
Such a triple receives a standard interpretation as a statement of partial
correctness: the assertion $\triple\pre\instr\post$ means that, in a state
where $\pre$ holds, it is safe to execute the instruction~$\instr$, and if
this execution terminates, then it leads to a final state where $\post$ holds.
A more precise statement is given in the next section (\sref{sec:soundness}).

\mytodo{iso todo: talk about each rule}
