\section{Program Logic for Location Virtualization}
\label{sec:logic}
% The predicate gen_heap_interp.
\newcommand{\gammaPred}{\delta}

\newcommand{\sumwalkabs}[3]{
  \ownGhost\gammaPred{\authfrag{\singletonMap{#1}{(#2, #3)}}}
}
\newcommand{\ptableabswalk}[1]{\mathcal{A}\textsf{bsPTableWalk}(#1)}
\newcommand{\ptablestore}{\theta}
Our reasoning principles are shaped around understanding the following main pillars of vritual-memory-management:
\begin{enumerate}
\item page-table walk: L4-L1 walk on shared page tables to reach a physical page address
\item allocating/updating a pages backing a virtual address 
\item switching from one address-space to another 
\end{enumerate}
%\subsection{Machine State under Address Translation}
%\label{sec:selectedinstrsemantics}
%Althought we give the complete set of operational semantics rule in \sref{appendix:movops}, It is worth building the intuition on the the way some of these rules bahave in the context of address translation. In fact $\readlval\maddr{\storememstar\crval}\locsf$ is unfoled into multiple physical memory lookups for the final page address retrieval -- i.e. address translation traversal as shown in Figure \ref{fig:pagetables}:
%\begin{itemize}
%\item top-level-address translation: with the given root address (64-bit $\crval$) of the address space, performs the address translation, handling the first level (to get the PML4 entry) itself. The next level table address is computed with the fetched PML4 offset value which exhibits itself as 9-bit offset in $\kw{maddr}$. \mytodo{iso: put move}
%\item translating from PML4 entry: performs the second level of address translation, to retrieve starting at the PML4 table entry, and interprets the PML4 entry that references a Page-Directory-Pointer Table (PDPT). We obtain the PDPT offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PDT) \mytodo{iso: put move}
%\item translating from PD entry: performs the third level of address translation, to retrieve starting at the PDP table entry, and interprets a PDPTE that references a PD table. Likewise, we obtain the PD offset which exhibits itself as 9 bit offset in $\kw{maddr}$ to obtain the address of the next level page directory table (PT) \mytodo{iso:put move }
%\item translate from PT entry: performs final level of address translation, starting from the PT entry, with a given 12 bit page offset, we can compute the physical address referencing $\locsf$ \mytodo{ismo: put mov}
%\end{itemize}
\subsection{Points-To Assertions}
\label{sec:pointsto}
As part of assertions on our machine state ($\sigma$), we abstract memory addresses and registers naming their relevant values through well-known separation logic assertion \textit{points-to}.
\begin{enumerate}
\item Physical address points-to, $\pfpointsto\locsf\locsf\qfrac\ppts$
\item Register points-to, $\pfpointsto\rg\rv\qfrac\rpts$
\end{enumerate}
\paragraph{Register points-to} The assertion $\pfpointsto\rg\rv\rpts\qfrac$ ensures the ownership of the register $\rg$ naming the register value $\rv$. The fraction $\qfrac$ with value 1 asserts the unique ownership of the register mapping, and grants update permission on it, otherwise, any value $0 < \qfrac <1$ represents partial ownership granting readonly permission on the mapping.
\paragraph{Physical-Memory points-to} Our physical memory points-to relation ($\pfpointsto\locsf\locsf\qfrac\ppts$) exhibits nested-mappings abstracting the  masks applied on the indexing virtual address ($\textsf{vaddr}\in\mathcal{W}_{64}$). The unfolded definition of the physical mapsto 
\begin{figure}[!ht]
\[
\begin{array}{cl}
\pfpointsto\locsf\locsf\qfrac\ppts \stackrel{def}{=} & \nfpointsto{\mask\locsf\ft\generalentry}{\mask\locsf\tw\generalentry}\locsf\qfrac\naddr
\end{array}
\]
\caption{Physical Points-to with Nested Masking}
  \label{fig:physicalpointsto}
\end{figure}
where, for an example virtual address \textsf{va} and given \textsf{CR3} in Figure \ref{}, we can abstract the L4-L1 table traversal as the following:
\begin{itemize}
  \item Page Map Level-4 Translation (L4): Calculating the offset to the 4 \textsf{Kbyte Physical Page} table to obtain the  physical address by  which resides in the last 12 bits of the virtual memory address, $\locsf|^{12}$,  shown in Figure \ref{}.
    % \pfpointsto{\lvlsum\crt\lfoff}{\lvlbor\lt}\qfracfotsss\ppts \star
    \[ \textsf{L4translate} \stackrel{\triangle}{=} \exists \entryf \ldotp \nfpointsto{\mask\vaddr\ft\crthree}{\mask\vaddr\tw\crthree}\entryf\qfracfotsss\naddr \]
  \item Page Directory Pointer Level Translation (L3):
    \[ \textsf{L3translate} \stackrel{\triangle}{=} \exists \entrytr \ldotp \nfpointsto{\mask\vaddr\ft\entryf}{\mask\vaddr\tw\entryf}\entrytr\qfracfotss\naddr \]
  \item Page Directory Table Level Translation (L2):  we obtain the address of the page table via \textsf{PDE}$|^{52}$ and picking the offset from the virtual memory address via imposing the mask to obtain page table offset bits (9 bits [20-12] shown in Figure \ref{}) to obtain the page table entry (\textsf{PTE}).
    \[ \textsf{L2translate} \stackrel{\triangle}{=} \exists \entrytw \ldotp \nfpointsto{\mask\vaddr\ft\entrytr}{\mask\vaddr\tw\entrytr}\entrytw\qfracfots\naddr \]
  \item Page Table Level Translation (L1):
    \[ \textsf{L1translate}  \stackrel{\triangle}{=} \exists \entryo \ldotp \nfpointsto{\mask\vaddr\ft\entrytw}{\mask\vaddr\tw\entrytw}\entryo\qfracfot\naddr \]
  \item Page Address Level Translation
    \[ \textsf{PageAccess} \stackrel{\triangle}{=} \exists \vpage \ldotp \nfpointsto{\mask\vaddr\ft\entryo}{\mask\vaddr\tw\entryo}\vpage\qfracone\naddr \]
    
\end{itemize}
\begin{remark}[A Strong Definition for Virtual Memory Addressing]
  \label{rem:strongvmem}
  One could give a naive logical definition to the virtual mememory addressing as conjuctions of each level translation (Figure \fref{fig:strongvirtualpointsto}). The very first assurance our logical constructions need to be able assert is the \textit{existence} of the page table walk. Our naive attempt shown in Figure \ref{figure:strongvirtualpointsto}, we see that a virtual address with a certain fractional permissions at each level of the page-table walk gives us sound assurance of the path existence reaching to a page table entry, consequently, with a full-ownership of page address, we can obtain and update the value mapped value at this physical page address through our virtual memory address. 

\begin{figure*}
  \[
  \begin{array}{l}
\begin{array}{l}
  \vaddr\mapsto_{\textsf{v}}\{\textsf{q}\}\vpage \stackrel{def}{=} \lambda \crthree.\\
  \exists_{\entryf \;, \entrytr \;, \entrytw \;,\entryo} \ldotp 

  \ulcorner \textsf{aligned } \vaddr \urcorner \star  \\
  \textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\entryf,\entrytr,\entrytw,\entryo)\\
   \nfpointsto{\mask\vaddr\ft\entryo}{\mask\vaddr\tw\entryo}\vpage\qfracone\naddr 
\end{array} \\

\textsf{where   }\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\entryf,\entrytr,\entrytw,\entryo) \stackrel{\triangle}{=} \\
 \qquad\qquad \nfpointsto{\mask\vaddr\ft\crthree}{\mask\vaddr\tw\crthree}\entryf\qfracfotsss\naddr \star \\ 
 \qquad\qquad  \nfpointsto{\mask\vaddr\ft\entryf}{\mask\vaddr\tw\entryf}\entrytr\qfracfotss\naddr  \star  \\
  \qquad\qquad \nfpointsto{\mask\vaddr\ft\entrytr}{\mask\vaddr\tw\entrytr}\entrytw\qfracfots\naddr \star \\
  \qquad\qquad \nfpointsto{\mask\vaddr\ft\entrytw}{\mask\vaddr\tw\entrytw}\entryo\qfracfot\naddr 
   \end{array}
\]
\caption{A Strong Virtual Points-to Relation}
\todo[inline]{These fractions aren't quite right (though I see you added the variance between levels), I can walk you through in our meeting tomorrow.}
  \label{fig:strongvirtualpointsto}
\end{figure*}
\end{remark}
%then we reach to a physical page addr (e.g. \textsf{pa}) 
%\[  \paddr\mapsto_{\textsf{a}}\{1\}\vsome \ast \nfpointsto{\mask\vaddr\ft\entryo}{\mask\vaddr\tw\entryo}\vpage\qfrac\naddr \]

  \subsection{Aliasing/Sharing Physical Pages}
  \label{sec:sharingpages}
  We already build the intuition on what a virtual address mapping is composed of: 1. traversing the page tables to reach the page table entry 2. obtaining the physical address, and accessing the value mapped.
  
One might have already observed that the virtual points-to definition shown in Figure \ref{fig:strongvirtualpointsto} is too strong to specify virtual memory operations updating a page table entry. Although there seems to fractional permissions for fragmental ownership of page-table entries, strong virtual points-to (in Figure \ref{strongvirtualpointsto}) relation doesn’t care about owning those fractional resources, it only cares that something ensures the correct page table walk exists. Any virtual memory operations such as mapping a new page which updates an page table entry would violate the soundness of other virtual-pointsto relations in the existence of page-sharing across the virtual addresses in the same address space. 

One possible approach to is to just abstracting the \textit{valid} page-table walk existence from a each virtual address (e.g. \textsf{va}) to a physical page address, as \textit{per-element} ownership of a logical \textit{page-table-walk-summarization-map}
\[\mathcal{A}\textsf{bsPTableWalk} \stackrel{\triangle}{=} \textsc{Auth} (\; \mathcal{W}_{64} \;\rightarrow_{\textrm{fin}} \;  (\mathcal{W}_{64} \; \rightarrow_{\textrm{fin}}\;  (\textsc{Frac }, \mathord{+}) \times (\textsc{Agree } \Loc,\mathord{=}) ))\]
provided by a fragmentery ghost resrource ownership of $\mathcal{A}\textsf{bsPTableWalk}$.
\begin{remark}[Exchanging Page-Table-Walk-Summarization Mappings (Tokens) with Physical Page-Table-Walk Pointstos ]
$\mathcal{A}\textsf{PTableWalk}$ is a ghost map resource where fragmental-ownership of an individual key-value pair (per-element) can be handled as a resource. We use this mechanism to separate the virtual-to-physical translation from the physical memory involved: virtual points-to assertions can be defined in terms of fragmental ownership (ownership of an element) of these partial ghost map entry assertions , $\sumwalkabs\vaddr\qfrac\paddr$, plus sharing an invariant ($\mathcal{I}$\textsf{ASpace} in Figure \ref{fig:peraspaceinvariant}) that the current installed page table respects all entries of the mapping, $\ownGhost\gammaPred{\authfull{\ptableabswalk\ptablestore}}$. From one another perspective, unmapping pages collects the fragmental map kvpairs, e.g. $\sumwalkabs\vaddr\qfrac\paddr$, from collecting the assertions, and then can remove them from the ghost map and update the page tables. Critically, physical full ownership of the page tables lives, $\ownGhost\gammaPred{\authfull{\ptableabswalk\ptablestore}}$, in the central invariant on the current page table, so some virtual pointsto assertions can refer to memory in those page tables.% This still works with the modality, since that invariant is also semantically a predicate on a page table root.
\end{remark}
Then, our virtual memory addressing would be the fragmental ownership of the abstract page-table-walk mapping with the physical page address mapping as shown in Figure \ref{fig:virtualpointstosharing}. 
\begin{figure*}
\[
\begin{array}{l}
  \textsf{VPointsTo}(\vaddr \;, \vpage)\stackrel{\triangle}{=} 
  \exists \entryo \ldotp 
  \sumwalkabs\vaddr\qfrac\paddr \star 
   \nfpointsto{\mask\vaddr\ft\entryo}{\mask\vaddr\tw\entryo}\vpage\qfracone\naddr
\end{array}
\]
\caption{Virtual-Pointsto for Sharing Pages}
  \label{fig:virtualpointstosharing}
\end{figure*}

\subsection{Address-Space Abstraction}
\label{sec:aspacemodal}
Abstractions we introduce for virtual address spaces are based on the following aspects:
\begin{enumerate}
\item a global address space invariant asserting the authorative ownership of the ghost map, $\ownGhost\gammaPred{\authfull{\ptableabswalk\ptablestore}}$ 
\item for each ghost page-table-walk mapping,  $\sumwalkabs\vaddr\qfrac\paddr$, there exists concrete physical page-table accesses path
  \[\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\entryf,\entrytr,\entrytw,\entryo)\]
  \item all virtual pointsto assertions happen to be true in a certain address space, i.e. the truth on address virtualization is indexed by CPUs page table register ($\crthree$ for x86-64), and we present modal reasoning principles for updating $\crthree$ (switching from the current address space to another)  
\end{enumerate}
    \subsubsection{Global Per-Address-Space Invariant}
    \label{sec:peraspaceinvariant}
    Virtual points-to assertions would need to be defined in terms of physical points-to assertions and hardware-specific address translation assertions for mapped virtual addresses ($\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\entryf,\entrytr,\entrytw,\entryo)$ in Figure \ref{fig:peraspaceinvariant}). For each virtual address \textit{mapped} with a physical page table entry, abstracted with ghost mappings ($\sumwalkabs\vaddr\qfrac\paddr$) in virtul-pointsto relations as shown in Figure \ref{fig:virtualpointstosharing}), there exsits a physical page table walk.  
    \[ \bigast{(\vaddr, \entryo)\in \ptablestore}{\exists\;(\entryf\;,\entrytr\;,\entrytw)\ldotp \textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\vaddr,\entryf,\entrytr,\entrytw,\entryo)} \]
    By separating the virtual-points Overlapping address spaces — both shared data, and shared page tables
which may see updates — can be coordinated with protocols to ensure those updates preserve
address space invariants.
\begin{figure*}
\[
\begin{array}{l}
  \mathcal{I}\textsf{ASpace} \stackrel{\triangle}{=} \lambda \; \crthree \ldotp
  \exists\;\gammaPred \;\ldotp\; \ownGhost\gammaPred{\authfull{\ptableabswalk\ptablestore}} \star \\
  \bigast{(\vaddr, \entryo)\in \ptablestore}{\exists\;(\entryf\;,\entrytr\;,\entrytw)\ldotp \textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}(\crthree,\vaddr,\entryf,\entrytr,\entrytw,\entryo)}
\end{array}
\]
\caption{Global Address-Space Invariant}
  \label{fig:peraspaceinvariant}
\end{figure*}
\subsubsection{Address-Space Modality}
\label{sec:aspacemodalist}

The truth on an address space, exhibits itself as a contingent truth: a location virtualization assertion (a virtual points-to in \ref{fig:virtualpointstosharing}),  happens to valid in the \textit{current world} (in the current address space), and switching address spaces pulls information out of one \textit{world} into the “current view” of memory, and leaves other assertions true relative to the previous address space.

Therefore, an address-space, as an abstraction, can be treated as naming the memory state as a modal frame and the choice of page table root as a world in Kripke-style semantics. Not suprisingly, transition between two address-spaces, then, can be just an entailment relation \textit{alternating} the \textit{named-state} against the address-space invariant ($\mathcal{I}\textsf{ASpace}$ in Figure \ref{fig:peraspaceinvariant}). 

Being inspired by what hybrid logic \ref{} calls a satisfaction operator, which evaluates the truth of a predicate in a named alternative state (here, address space), we give a modal definition describing the truth of assertions for the resources inside the address space, $[r]P$ indicating that $P$ holds in the virtual address space rooted at $r$. While doing so, we explain what a modal resource context is, and how it interacts with the ambient logic, i.e. separation logic.
\paragraph{Modal Resource Context}
\label{sec:resourcecontext}
When we pick up a certain contingency, which is \textit{"a certain virtual-pointsto facts whose validity is indexed by the root address of an address space"}for address space modality, we, in fact, make our choice around some logical resources for which we care about reasoning, which is virtual pointsto relation shown in Figure \ref{fig:virtualpointstosharing}.
\paragraph{Interaction}
\label{sec:interaction}

\subsection{Considering Hoare Doubles in the Context of Switching Address-Space}
An important subtlety arises with supporting \lstinline|mov|s into \lstinline|%cr3|. Consider the hypothetical rule:
\begin{mathpar}
\inferrule[Broken]{ }{
  \{P \ast cr3=r_1 \ast r=r_2 \ast [r_2](Q)\}
  \texttt{mov}~\texttt{\%cr3},~r%\lstinline|mov %cr3, r| 
  \{[r_1](P) \ast cr3=r_2 \ast r = r_2 \ast Q\}
}
\end{mathpar}
This rule captures the intuitive change of address space in a Hoare triple, rather than double, form. The problem with this is that it interacts quite poorly with the traditional frame rule and the modal flavor of virtual points-to assertions:
\begin{mathpar}
  \inferrule*[right=Frame]{
    \inferrule*[right=Broken]{ }{
    \{\mathsf{emp} \ast cr3=r_1 \ast r=r_2 \ast [r_2](Q)\}
    \texttt{mov}~\texttt{\%cr3},~r%\lstinline|mov %cr3, r| 
    \{[r_1](\mathsf{emp}) \ast cr3=r_1 \ast r=r_2 \ast Q\}
    }
  }{
    \{a\mapsto_\mathsf{v} x \ast \mathsf{emp} \ast cr3=r_1 \ast r=r_2 \ast [r_2](Q)\}
    \texttt{mov}~\texttt{\%cr3},~r%\lstinline|mov %cr3, r| 
    \{a\mapsto_\mathsf{v} x \ast [r_1](\mathsf{emp}) \ast cr3=r_1 \ast r=r_2 \ast Q\}
  }
\end{mathpar}
Notice that both the precondition and postcondition assert that $a\mapsto_\mathsf{v} x$ in the current address space, but we have no basis for concluding that address translation is preserved by the change of address space. So this derivation clearly leads to an unsound conclusion. This suggestss that the traditional frame rule and the Hoare triple presentation of the change-of-address-space rule cannot soundly coexist in the same system.
The heart of the problem is that while updating \lstinline|cr3| is \emph{physically} local, it globally changes the interpretation of virtual addresses. So it is simply unsound to frame around \lstinline|cr3| updates.

Switching to Hoare doubles resolves this problem because an under-appreciated subtlety of Hoare doubles is that typically \emph{there is no frame rule}. Instead each verification essentially includes a local frame that it passes to the next instructions (think continuation-passing style), giving each overall rule a \emph{global} (rather than local) precondition. For most rules this is not that important, but it does permit rules that have global effects on their preconditions.

This is then how we justify our actual rule for \lstinline|cr3| updates:
\begin{mathpar}
\inferrule[ChangeAddressSpace]{
  \{[r_1](P) \ast cr3=r_2 \ast r = r_2 \ast Q\}\overline{is}
}{
  \{P \ast cr3=r_1 \ast r=r_2 \ast [r_2](Q)\}
  \texttt{mov}~\texttt{\%cr3},~r;\;\overline{is}
  %\lstinline|mov %cr3, r| 
}
\end{mathpar}
Because the precondition on this rule is global, we avoid issues with framing.

If we wanted to consider a frame rule that would work for this logic, we could consider:
\begin{mathpar}
  \inferrule[Cr3Frame]{
    \{P\ast cr3=v\}\;C\;\{ Q \ast cr3=v\}
  }{
    \{R\ast P\ast cr3=v\}\;C\;\{ R \ast Q \ast cr3=v\}
  }
\end{mathpar}
By demanding that \lstinline|cr3| be held constant (or rather, at least restored to its original value) we could frame almost traditionally. In particular, this rule would work with framing around calls that might lead to address space switches, such as calling blocking operations in the kernel.

Readers familiar with dynamic frames~\cite{parkinson2011relationship} might find it useful to notice that a different perspective on this matter is that virtual points-to assertions are self-stable \emph{except} for changes in \lstinline|cr3|, so framing would then naturally require other means of holding \lstinline|cr3| constant (or saving and restoring it).
Virtual points-to assertions could be made self-stable by also giving them partial ownership over \lstinline|cr3| assertions, but this would require explicitly plumbing that ownership from \emph{all} assertions back to any place an address space change might occur; this would seem to be a far graver loss of modularity than this extra quirk in framing discussions.
