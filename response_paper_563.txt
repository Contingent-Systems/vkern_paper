
OVERVIEW
Thank you so much for your valuable reviews. For clarifying, here are our answers to provide more clarification.
We will incorporate the structural changes suggested to improve the exposition, as well as the smaller comments as part our paper-presentation refinement.
We fixed the inconsistency in the page-insertion example, and removed the axiom we used to introduce it after the fix.


Review: 563A - "There are about 11 axioms admitted about details of the physical model.
       	        I'm not an absolutist about these things, and I don't mind admitting axioms that are, say, well-known mathematical facts,
	       	but that doesn't seem to be quite what's going on here. Similarly, for one of the case studies, the paper says that
	       	the proof got stuck because actually the stated post-condition isn't quite right, and there wasn't time to fix it,
	       	so the development has to admit an axiom related to that too."

		"What is the status of the remaining axioms? Have you made progress on removing them?"	
	     
       563B  - "At the moment our proofs do rely on 11 small axioms of properties which should be provable,
	       	but are challenging to discharge due to some representation choices in our model."
	       	"Reaching right at this point in the specification, we must note that we did find a trivial inconsistency in the postcondition related to conflating
	       	fpaddr as an address with the page table entry that reference fpaddr, and while the fix is straightforward we ran out of time."
	       	Both of these should have been mentioned much earlier and explained more clearly.""

      563C  -  "However the semantics of page tables is quite fiddly (as you appear to have discovered with the final axiom and associated comment), so I think care does need to be taken here!"
        	      
>> Response: There was one crucial axiom that we used which allowed an inconsistency in the post condition of page-insert example. We have fixed it. The remaining axioms are assertions for the equivalances of stddp gmap (used in the logic) vs FMapInterface/List (used in our amd64 model) for register and pyhsical memory map update/lookups. 
	  
Review: 563A - "One more minor issue is that the paper suggest that prior to this work, hybrid modal separation logics have seen "no prior application".
  	        I don't think that's quite right. For example, the iGPS weak memory logic of Kaiser et al. 2017 uses hybrid logic for reasoning about C11 weak memory:
	   	in iGPS, propositions are indexed by "views" (roughly, the subset of memory operations a thread has seen).
	       	They embed these view-indexed propositions in Iris and have a similar modality P[V] saying "under view V, P holds".
	       	In fact, this is one of the motivations for why the Iris proof mode supports such "embedded" logics with these kinds of modalities so well,
	       	as described in Krebbers et al.'s 2018 MoSeL paper."

	563B -  "You introduce the vProp universe without any reference to the existing work.
		 Iris has a monPred construction for indexed iProps that subsumes your use case.
		 This construction has been used in 2 different Iris papers, combining program logics with hybrid logic in much the same way you do,
		 but to reason about weak rather than virtual memory. Your statement that this has not been done before is hence incorrect.
		 You should reference these papers and weaken your novelty claim on this front. *.
		 Hoang-Hai Dang, Jacques-Henri Jourdan, Jan-Oliver Kaiser, and Derek Dreyer. 2019.
		 RustBelt meets relaxed memory. Proc. ACM Program. Lang. 4, POPL, Article 34 (January 2020), 29 pages. https://doi.org/10.1145/3371102 *.
		 Hoang-Hai Dang, Jaehwang Jung, Jaemin Choi, Duc-Than Nguyen, William Mansky, Jeehoon Kang, and Derek Dreyer. 2022.
		 Compass: strong and compositional library specifications in relaxed memory separation logic.
		 In Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2022).
		 Association for Computing Machinery, New York, NY, USA, 792â€“808. https://doi.org/10.1145/3519939.3523451"

>> Response: Thank you for the pointers, we will cite these and adjust our claims accordingly (and at some point shift to using monPred rather than our own pointwise lifting).

Review: 563A - "Can you please clarify rule WriteToRegCtlFromReg? It seems to me that the P above the line should be under a modality since the page register has changed,
	        as in the more elaborate rule beneath it."

>> Response: WriteToRegCtlFromReg was accidentially left there, it is a pre-modal rule for updates (its assertions are iProps rather than vProps) used to build up the modal rule, and should have been omitted from the paper.

Review: 563B - "The paper is not accessible to readers without Iris knowledge. Rather than focusing on the rules/interfaces you want your ghost resources to satisfy,
	        you show the entire resource algebra construction with little explanation. This makes explanations harder to follow and more convoluted than they need to be.
		The paper contains various notational inconsistencies, and is hand-wavy at times when formal rigour matters.
		For example, Figures 11 and 12 were very difficult to read for this reason (see below)."
>> Response: We conceptualize the logical resources and their interactions in Figure 7 and explain them in a Iris-independent way.
	  We will also refine them based on your suggestions.

Review 563B - "The formal machinery seems to be there, but the evaluation is lacking: the examples you verify in the paper are toy examples of code fragments;
       	       they concern no more than a few assembly instructions, and have no interaction with surrounding code.

	       + The page mapping example is unfinished, as it only maps 64 bits (which you fail to mention until the end of the section),
	       	 relies on axioms as before, and makes some strange representational choices. I discuss this in detail in the comments below."

		 >> Response: The example does map a full page, but only proves the single entry is mapped; verifying the full-page mapping requires plumbing a big-op through the proof, which is longer but not fundementally difficult. We did axiomatize the preparation of the L1 entry; this is not unlike assumptions made in Kolanski and Klein's papers, where the actual preparation of the page is not modeled (but the retrieval of a page to map from a simple free-page-list is included in their work).

	       + The address space switching example would be much more convincing if you actually verified it against a few concrete processes to obtain an end-to-end result.
	       	 Currently it is quite trivial, because you leave P and Pother opaque.
		 This makes it much harder to explain as well.

		 >> Response: This is actually the correct form for actual context switching code for a general-purpose OS. We can better explain the intended context of that example, but most kernels have a single function which implements a context switch, which is used for every single context switch the OS performs, regardless of which processes are being switched from/to. That particular function would be called with the current thread of the current address space (so it is callable in any address space, and usually from multiple call sites, so even the caller context is not fixed), and with some arbitrary other target process address space (whichever the scheduler decided should run next, including switching to processes which were preempted). P and Pother are opaque because they are and should be parameters to the specification of the context switch function. Consider, e.g., OpenBSD's ```cpu_switchto``` (https://github.com/openbsd/src/blob/master/sys/arch/amd64/amd64/locore.S#LL273C20-L273C20 with the CR3 update on line 415); this is used to switch from any process that is blocking (or terminating) to any other process that is supposed to run, and an analogous assembly fragment exists in Linux, MacOS, Windows, FreeBSD.... (that OpenBSD code snippet is dealing with additional scheduling metadata and more novel stack management than our example, which is focused on the core of the context switch and only integer/program registers).
		 
	       + I expected to see the result that you mentioned in the related work:
	         "Kolanski and Klein prove very useful embedding theorems stating that code that does not modify page table entries can be verified in a VM-ignorant program logic,
	       	 and that proofs in that logic can be embedded". This seems like a must-have if you intend to verify interesting examples.

		 >> Response: Strictly speaking, Kolanski and Klein can prove that because their assertions and logical rules are defined inductively, making it possible to prove the embedding by induction over the rules in the VM-ignorant logic. In Iris neither assertions nor proof rules are closed, so such a result cannot be directly proven. It does not even make sense to talk about ideas like assertions that don't use certain constructs, since the user can add new vProps (or iProps in Iris in general). Instead we would highlight that our rules that do not manipulate page tables or cr3 are the same rules one would see for any other Hoare double logic, just passing IASpace and the cr3 value through without change.

	       + You should have at least one example that implements what you describe in section 4.3, and supports many address spaces.
	       	 You currently have no proof that this will actually work.

		 >> Response: As mentioned in Section 4.3, the details of packaging all of the address spaces together is highly dependent on other kernel policies we are not attempting to model, and we do not believe a strawman will be informative. The simplest version, where all address spaces are simply disjoint, would simply involve another layer of ghost maps from process identifiers to $\Theta$ and $m$ for the particular address space.

	       + Does your paging need to be this specific to x86-64? Does it have to have four levels?
	       	 Could you somehow parameterize your implementation by the concrete paging implementation?
	       	 It is likely worthwhile to switch to a single- or two-level paging scheme for the initial examples.

		 >> Response: We build our principles on top of our amd64 model with 4-Levels paging.
		    	      This is a current implementation limitation, but not a fundamental limitation.
		              Right now, our reasoning principles are not shaped to be parameterized with paging-policy, but
			      since our reasoning principles are not paging-policy dependent, we can parameterize them on the paging-policy; this amounts to
                              making L4_L1_PointsTo and some associated properties regarding its accurate modeling of page table walks into a parameter. 

Review 563B - "Describe the exact subset of x86-64 that you support in more detail.
       	       It seems very limited right now. Motivate why this is still an interesting subset.
	       This would also avoid the aforementioned issue where the call instruction suddenly pops up without prior introduction."

>> Response: For us, the subset is interesting because it is the subset needed to model the core challenges of reasoning about address translation.
             The subset supported by the logic includes 64-bit register and memory mov instructions, mov with a 32-bit immediate to set a register, and adding a 32-bit immediate value to a 64-bit register. We can clarify this very early in the paper. The hardware model supports more (see ```external/amd64coq/src/Instructions.v```).
             Our priority for this paper was the principles for reasoning with virtual memory, which can be explored with only the instructions we have rules for (though more convincing contextual examples, as noted, to benefit from use of call, hence our axiomatization of ensure_L1).
	     

Review 563B - "Fig. 11 is frustratingly difficult to read in combination with the text, for various reasons: "

       	      + All of the interesting work required in Figure 11 happens inside the 2 opaque calls, which you do not show any implementation of.
	      	I went to check your development, and your auxiliary methods are simply Axioms! This is misleading and should be signposted clearly in the paper.
		Actually implementing and verifying these calls could have prevented many of the issues popping up in the text and the figure."

		>> Response: We can (and should) definitely signpost these aspects earlier to avoid surprising readers. However, we disagree that all of the interesting work happens in the auxilliary functions. The focus of our work is on manipulating the active page table mappings, and while ensure_L1 does abstract some of this (no more than prior work on logics for virtual memory) it retains both the final mapping operation and critically retains the creation of a new virtual points-to fact from constituent pieces.

	      + "Many details that you show in the proof are only partly explained (and in a convoluted way) in the text; e.g., is pte_addr just an alias pointing to pa for convenience reasons?
	      	 Why does it point to wzero 64 and not some existentially quantified value (a function called ensure_L1_page does not sound like it will unmap the previous entry)? etc."

		 >> Response: For the sake clarity in the example, we wanted to have the entry already zeroed. If it were not, the code snippet would also have to deal with deallocating the page that entry previously pointed to.

	       + "Does aligned mean word-aligned or page aligned? From fig.11 I am getting the impression that it is the latter but Fig.4 gave the opposite impression.
	       	  753 Where does this +3 come from? The text mentions +1, which I don't get either; fpaddr is said to be aligned, not fpaddr + 3. Additionally, 811 directly contradicts this.

		 >> Response: This word is unfortunately overloaded; our mechanization has separate predicates for being page-aligned and word-aligned. Figure 4 & 5 are talking about word alignment, but Figure 11 is dealing with page alignment. We can clarify this in the paper.
                    You also noticed hints of a mistake in our specification of Figure 11 which we found and fixed shortly after submission: the code there is inconsistent about whether fpaddr is page aligned or has the two low-order bits set (i.e., whether it's a page-aligned address plus 0x3) to indicate a valid (bit 0) and read-write (bit 1, as opposed to read-only) page table entry. But the +1 and +3 are about setting the validity and read-write bits in the x86-64 page table entry.		 

Question 563B: "(related to remarks about section 4.5 above) Would it be possible to support (1) a frame rule that applies to Facts only together with
	  	(2) a way to convert "P * cr3 = v" into "[v] P" and to convert "[v] P * cr3 = v" back into "P" and
		(3) the assumption that [v] P is always a Fact."

>> Response: Yes, a frame rule that only frames out Facts would be possible for (1). (3) is trivially true by the definitions of Fact and the modality in Figure 8. (2) isn't quite right as written, as it is inconsistent about where the register resource for cr3 goes. But ```[v](P) * cr3=v -||- P * cr3=v``` holds for our model.

Questions 536B: "How would you share the kernel page tables in multiple processes?
	  	 It seems you have hard-coded the fractions for the physical points-tos in Figure 4
		 (although you only mention this on line 1016) under the assumption that no page table sharing occurs,
		 so the sum of all fractions would be n in the case of n-way sharing.
		 This is why I think having more complicated examples is required for evaluation."

>> Response: Figure 4 has not been used in any of the reasoning, it is a simpler baseline that we improve upon in Figure 5, which is what we actually use.
             The typesetting there is slightly misleading, as q4 is actually defined in our implementation as 1/512 (since the L1 PTE maps 512 8-byte words),
             q2 is 1/(512*512) since an L2 entry maps 512 L1 tables, and so on. You are correct that supporting page table sharing would require more flexible fractions;
             as with other decisions, we have actively avoided committing to artificially specialized models of sharing that may not generalize to the actual sharing
             that occurs in real kernels, the treatment of which is our longer-term goal. Our current hardware model has only a single core, so separating implication
             (e.g., <shared page table portion> -* IASpace(T,m)) could be used to borrow the shared portion while running in another address space.

Question 563B: "Your virtual points-to chunks require full ownership of physical memory in Fig.5.
	        It seems like in most cases (when you're not editing page tables) you do not care about the fraction of the page table mapping you possess,
		but you do care about the fraction of physical memory.
		-> It seems strange that the entailment va |->_v {q1 + q2} val |- va |->_v {q1} val \ast va |->_v {q2} val does not hold? ->
		How would you go about mapping physical memory in multiple virtualized processes (e.g. when forking a process or sharing memory)?
		It seems like you get into trouble because multiple processes need to own the same physical memory, which is not susceptible to the [r]-modality."

>> Response: First, there is a typo fix on the Figure 5 where the fraction q bound in the first line should appear in "pa ->p{q} val" on the second line, which is what our mechanization uses. So it is possible to have two virtual points-to assertions with shared fractional ownership of the data but which correspond to virtual address aliasing (whether within or across address spaces). The definition of our virtual points-to already supports that, though we have not proven rules to allow the construction of such a situation without unfolding the definition, and it is not obvious what those rules should be for cross-process sharing. More precisely, it is not clear what the appropriate logical modeling of transferring ownership between the processes should be. We consider this future work; our model is already more flexible than prior work and asking the paper to present a full solution to cross-process memory sharing is asking for a solution to a different (though complementary and related) problem than we set out to solve (logical foundations of address space management with a focus on task switching).
	     

Question 563B: "Could you support the root of the page table being moved to a different physical address? Is it possible to change the index in ASpaces to make IAAspace hold again?"

>> Response: Making the IASpace a non-permanent assertion (which is in-fact something we used in the mechanized proof) makes this feasible.

Some Small Comments 536B: "The black later means something different than what you think in Iris; it is an endofunctor on the category of OFEs! What you want is the white triangle."

>> Response: Yes, we are well-aware of this, thanks.
