
OVERVIEW
Thank you so much for your valuable reviews. For clarifying, here are our answers to provide more clarification.
In general, we incorporated the structural changes and small comments as part our paper-presentation refinement.
We fixed the inconsistency in the page-insertion example, and removed the axiom we used to introduce it after the fix.


Review: 563A - "There are about 11 axioms admitted about details of the physical model.
       	        I'm not an absolutist about these things, and I don't mind admitting axioms that are, say, well-known mathematical facts,
	       	but that doesn't seem to be quite what's going on here. Similarly, for one of the case studies, the paper says that
	       	the proof got stuck because actually the stated post-condition isn't quite right, and there wasn't time to fix it,
	       	so the development has to admit an axiom related to that too."

		"What is the status of the remaining axioms? Have you made progress on removing them?"	
	     
       563B  - "At the moment our proofs do rely on 11 small axioms of properties which should be provable,
	       	but are challenging to discharge due to some representation choices in our model."
	       	"Reaching right at this point in the specification, we must note that we did find a trivial inconsistency in the postcondition related to conflating
	       	fpaddr as an address with the page table entry that reference fpaddr, and while the fix is straightforward we ran out of time."
	       	Both of these should have been mentioned much earlier and explained more clearly.""

        	      
>> Response: There was one crucial axiom that we used and introducing inconsistency in the post condition of page-insert example, and we fixed
	  it. Other axioms are assertions for the equivalances of stddp gmap (used in the logic) vs FMapInterface/List (used in our amd64 model) for register and pyhsical
	  memory map update/lookups, these do not impose any importance on our reasoining principles and semantics of amd64 model. 
	  
Review: 563A - "One more minor issue is that the paper suggest that prior to this work, hybrid modal separation logics have seen "no prior application".
  	        I don't think that's quite right. For example, the iGPS weak memory logic of Kaiser et al. 2017 uses hybrid logic for reasoning about C11 weak memory:
	   	in iGPS, propositions are indexed by "views" (roughly, the subset of memory operations a thread has seen).
	       	They embed these view-indexed propositions in Iris and have a similar modality P[V] saying "under view V, P holds".
	       	In fact, this is one of the motivations for why the Iris proof mode supports such "embedded" logics with these kinds of modalities so well,
	       	as described in Krebbers et al.'s 2018 MoSeL paper."

	563B -  "You introduce the vProp universe without any reference to the existing work.
		 Iris has a monPred construction for indexed iProps that subsumes your use case.
		 This construction has been used in 2 different Iris papers, combining program logics with hybrid logic in much the same way you do,
		 but to reason about weak rather than virtual memory. Your statement that this has not been done before is hence incorrect.
		 You should reference these papers and weaken your novelty claim on this front. *.
		 Hoang-Hai Dang, Jacques-Henri Jourdan, Jan-Oliver Kaiser, and Derek Dreyer. 2019.
		 RustBelt meets relaxed memory. Proc. ACM Program. Lang. 4, POPL, Article 34 (January 2020), 29 pages. https://doi.org/10.1145/3371102 *.
		 Hoang-Hai Dang, Jaehwang Jung, Jaemin Choi, Duc-Than Nguyen, William Mansky, Jeehoon Kang, and Derek Dreyer. 2022.
		 Compass: strong and compositional library specifications in relaxed memory separation logic.
		 In Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2022).
		 Association for Computing Machinery, New York, NY, USA, 792â€“808. https://doi.org/10.1145/3519939.3523451"

>> Response: We need to cite the papers introducing propositions indexed by a certain view of a thread P[V], monPred and others. (Colin, would you like to add more on this?)

Review: 563A - "Can you please clarify rule WriteToRegCtlFromReg? It seems to me that the P above the line should be under a modality since the page register has changed,
	        as in the more elaborate rule beneath it."

>> Response: WriteToRegCtlFromReg accidentially left there, it cannot coexists with the rule below (WriteToRegCtlFromRegModel), it is fixed.

Review: 563B - "The paper is not accessible to readers without Iris knowledge. Rather than focusing on the rules/interfaces you want your ghost resources to satisfy,
	        you show the entire resource algebra construction with little explanation. This makes explanations harder to follow and more convoluted than they need to be.
		The paper contains various notational inconsistencies, and is hand-wavy at times when formal rigour matters.
		For example, Figures 11 and 12 were very difficult to read for this reason (see below)."
>> Response: We conceptualize the logical resources and their interactions in Figure 7 and explain them in a Iris-independent way.
	  We also refined them based on your suggestions accordingly.	

Review 563B - "The formal machinery seems to be there, but the evaluation is lacking: the examples you verify in the paper are toy examples of code fragments;
       	       they concern no more than a few assembly instructions, and have no interaction with surrounding code.

	       + The page mapping example is unfinished, as it only maps 64 bits (which you fail to mention until the end of the section),
	       	 relies on axioms as before, and makes some strange representational choices. I discuss this in detail in the comments below."

		 >> Response: True, our page-insertion example currently relies on axiomatized call ensuring the L1 entry, and we add the call/return/branchinng instructions in our change-list to be finished.
		              However, reasoning over multiple-page vs. single page, in principle, is a trivial extension to support (big-op) over a container of pages, and does not exhibit any interesting
			      logical challenge that  we would like to discuss and explain in the page-insert example.

	       + The address space switching example would be much more convincing if you actually verified it against a few concrete processes to obtain an end-to-end result.
	       	 Currently it is quite trivial, because you leave P and Pother opaque.
		 This makes it much harder to explain as well.

		 >> Response: 
		 
	       + I expected to see the result that you mentioned in the related work:
	         "Kolanski and Klein prove very useful embedding theorems stating that code that does not modify page table entries can be verified in a VM-ignorant program logic,
	       	 and that proofs in that logic can be embedded". This seems like a must-have if you intend to verify interesting examples.

		 >> Response: 

	       + You should have at least one example that implements what you describe in section 4.3, and supports many address spaces.
	       	 You currently have no proof that this will actually work.

		 >> Response: (Colin, would you put some stuff here?)

	       + Does your paging need to be this specific to x86-64? Does it have to have four levels?
	       	 Could you somehow parameterize your implementation by the concrete paging implementation?
	       	 It is likely worthwhile to switch to a single- or two-level paging scheme for the initial examples.

		 >> Response: We build our principles on top of our amd64 model with 4-Levels paging.
		    	      There is no fundamental restriction to extend our reasoning principles to more than four-levels.
		              Right now, our reasoning principles are not shaped to be parameterized with paging-policy, but
			      since our reasoning principles are not paging-policy dependent, we can parameterize them on the paging-policy. 

Review 563B - "Describe the exact subset of x86-64 that you support in more detail.
       	       It seems very limited right now. Motivate why this is still an interesting subset.
	       This would also avoid the aforementioned issue where the call instruction suddenly pops up without prior introduction."

>> Response: For us, "interesting" implies the necessity to model the address virtualization, i.e. pieces needed for address-translation.
   	     In this submission, particularly in the page-insertion example, we intended to show how we abstract away the page-table walk from the memory points-to relation
	     with our reasoning principles, and this was our primary intention to share in the paper.
	     It is true that, by the time we submitted this paper, we miss the "call" instruction, and relied on its axiomatization, then it is put in our change-list to be finished as the next step.
	     

Review 563B - "section 4.5: I am unconvinced by the justification for dropping the frame rule, both the argument that it is necessary and the argument that it is unproblematic..."

>> Response: (Colin: I am aware of the discussion we had but I really don'y understand this text)


Review 563B - "Fig. 11 is frustratingly difficult to read in combination with the text, for various reasons: ..."



>> Response: (Colin, I should speak about these with Colin)

Question 563B: "(related to remarks about section 4.5 above) Would it be possible to support (1) a frame rule that applies to Facts only together with
	  	(2) a way to convert "P * cr3 = v" into "[v] P" and to convert "[v] P * cr3 = v" back into "P" and
		(3) the assumption that [v] P is always a Fact."

>> Response: All trivial by definition

Questions 536B: "How would you share the kernel page tables in multiple processes?
	  	 It seems you have hard-coded the fractions for the physical points-tos in Figure 4
		 (although you only mention this on line 1016) under the assumption that no page table sharing occurs,
		 so the sum of all fractions would be n in the case of n-way sharing.
		 This is why I think having more complicated examples is required for evaluation."

>> Response: Figure 4 has not been used in any of the reasoning. We have just mentioned it to motivate our virtual pointsto definition in Figure 5.
   	     However, altough they are misleadingly used as hard-coded fractions in the code-base, we can define a fraction at a certain-level in terms of the previous level.
	     At this moment, we do not support kernel-page-table management, and it is also becoming a recent attitude of OSes to be restrictive on the kernel page-table accesses (more isolation)
	     after  "spectre meltdown".

Question 563B: "Your virtual points-to chunks require full ownership of physical memory in Fig.5.
	        It seems like in most cases (when you're not editing page tables) you do not care about the fraction of the page table mapping you possess,
		but you do care about the fraction of physical memory.
		-> It seems strange that the entailment va |->_v {q1 + q2} val |- va |->_v {q1} val \ast va |->_v {q2} val does not hold? ->
		How would you go about mapping physical memory in multiple virtualized processes (e.g. when forking a process or sharing memory)?
		It seems like you get into trouble because multiple processes need to own the same physical memory, which is not susceptible to the [r]-modality."

>> Response: First, there is a typo fix on the Figure 5 where the fraction has to appear on ->p, it is fixed .
   	     On the other hand, we would introduce another level of abstraction to bookkeep the accesses to physical memory locations which are shared across the processes.
	     This would look like and be on of the one we introduced of abstracting the physical-page-table walk away from virtual points-to, whereas, this abstraction would
	     just hold the mappings from root addresses of address-spaces to the physical-memory locations accesses.
	     

Question 563B: "Could you support the root of the page table being moved to a different physical address? Is it possible to change the index in ASpaces to make IAAspace hold again?"

>> Response: Just making the IASpace to non-permanent assertion (which is in-fact something we used in the mechanized proof) introduces this capability.
